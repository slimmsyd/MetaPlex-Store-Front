"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkPath = exports.sleep = void 0;
const tslib_1 = require("tslib");
const arbundles_1 = require("arbundles");
const fs_1 = require("fs");
const mime_types_1 = (0, tslib_1.__importDefault)(require("mime-types"));
const p = (0, tslib_1.__importStar)(require("path"));
const fast_glob_1 = (0, tslib_1.__importDefault)(require("fast-glob"));
//import PromisePool from "@supercharge/promise-pool"
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
exports.sleep = sleep;
const checkPath = (path) => (0, tslib_1.__awaiter)(void 0, void 0, void 0, function* () { return fs_1.promises.stat(path).then(_ => true).catch(_ => false); });
exports.checkPath = checkPath;
class Uploader {
    //private syncMutex: boolean;
    constructor(api, utils, currency, currencyConfig) {
        this.api = api;
        this.currency = currency;
        this.currencyConfig = currencyConfig;
        this.utils = utils;
    }
    /**
 * Uploads a file to the bundler
 * @param path to the file to be uploaded
 * @returns the response from the bundler
 */
    uploadFile(path) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            if (!(yield (0, exports.checkPath)(path))) {
                throw new Error(`Unable to access path: ${path}`);
            }
            //const signer = await this.currencyConfig.getSigner();
            const mimeType = mime_types_1.default.lookup(path);
            const tags = [{ name: "Content-Type", value: (mimeType ? mimeType : "application/octet-stream") }];
            const data = (0, fs_1.readFileSync)(path);
            return yield this.upload(data, tags);
        });
    }
    /**
     * Uploads data to the bundler
     * @param data
     * @param tags
     * @returns the response from the bundler
     */
    upload(data, tags) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            // try {
            const signer = yield this.currencyConfig.getSigner();
            const dataItem = (0, arbundles_1.createData)(data, signer, { tags });
            yield dataItem.sign(signer);
            return yield this.dataItemUploader(dataItem);
        });
    }
    uploadFolder(path, indexFile) {
        var _a;
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            path = p.resolve(path);
            let alreadyProcessed = [];
            if (!(yield (0, exports.checkPath)(path))) {
                throw new Error(`Unable to access path: ${path}`);
            }
            // manifest operations
            const manifestPath = p.join(p.join(path, `${p.sep}..`), `${p.basename(path)}-manifest.json`);
            let manifest = {
                "manifest": "arweave/paths",
                "version": "0.1.0",
                "paths": {}
            };
            if (yield (0, exports.checkPath)(manifestPath)) {
                const d = yield fs_1.promises.readFile(manifestPath);
                manifest = d.length > 0 ? JSON.parse((d).toString()) : manifest;
                alreadyProcessed = Object.keys(manifest.paths);
            }
            if (indexFile) {
                indexFile = p.join(path, indexFile);
                if (!(yield (0, exports.checkPath)(indexFile))) {
                    throw new Error(`Unable to access path: ${indexFile}`);
                }
                manifest["index"] = { path: p.relative(path, indexFile) };
            }
            yield this.syncManifest(manifest, manifestPath);
            let files = yield (0, fast_glob_1.default)([`${path}/**/*`], { dot: false });
            //find already deployed files and remove them from the processing queue.
            files = files.filter((el) => !alreadyProcessed.includes(p.relative(path, el)));
            if (files.length == 0) {
                console.log("No items to process");
                //return the txID of the last deploy
                const idpath = p.join(p.join(path, `${p.sep}..`), `${p.basename(path)}-id.txt`);
                if (yield (0, exports.checkPath)(idpath)) {
                    return (yield fs_1.promises.readFile(idpath)).toString();
                }
                return undefined;
            }
            // TODO: add preflight balance check.
            let total = 0;
            for (let i = 0; i < files.length; i++) {
                total += (yield fs_1.promises.stat(files[i])).size;
            }
            console.log(`Total amount of data: ${total} - cost: ${yield this.utils.getPrice(this.currency, total)} ${this.currencyConfig.base[0]}`);
            return (_a = (yield this.bulkUploader(files, path)).manifestTx) !== null && _a !== void 0 ? _a : "none";
        });
    }
    /**
     * Asynchronous chunking uploader, able to upload an array of dataitems or paths
     * Paths allow for an optional arweave manifest, provided they all have a common base path <path>
     * Syncs manifest to disk every 5 (or less) items.
     * @param items - Array of DataItems or paths
     * @param path  - Common base path for provided path items
     * @returns - object containing responses for successful and failed items, as well as the manifest Txid if applicable
     */
    bulkUploader(items, path) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const promiseFactory = (d, x) => {
                return new Promise((r, e) => {
                    (typeof d === "string" ? this.uploadFile(d) : this.dataItemUploader(d))
                        .then(re => r({ i: x, d: re })).catch(er => e({ i: x, e: er }));
                });
            };
            const uploaderBlockSize = 5; //TODO: evaluate exposing this as an arg with a default.
            const manifestPath = path ? p.join(p.join(path, `${p.sep}..`), `${p.basename(path)}-manifest.json`) : undefined;
            const manifest = path ? JSON.parse((yield fs_1.promises.readFile(manifestPath)).toString()) : undefined;
            const hasManifest = (manifestPath && typeof items[0] === "string");
            const failed = new Map();
            const processed = new Map();
            try {
                for (let i = 0; i < items.length; i = Math.min(i + uploaderBlockSize, items.length)) {
                    const upperb = Math.min(i + uploaderBlockSize, items.length);
                    console.log(`processing items ${i} to ${upperb}`);
                    const toProcess = items.slice(i, upperb);
                    let x = 0;
                    const promises = toProcess.map((d) => {
                        x++;
                        const p = promiseFactory(d, (i + x - 1));
                        return p;
                    });
                    const processing = yield Promise.allSettled(promises);
                    //re-process failed promises and add fulfilled ones
                    // TODO: fix type
                    outerLoop: //loop label magic
                     for (let x = 0; x < processing.length; x++) {
                        let pr = processing[x];
                        if (pr.status === "rejected") {
                            const dataItem = items[pr.reason.i];
                            for (let y = 0; y < 3; y++) {
                                yield (0, exports.sleep)(1000);
                                const d = (yield Promise.allSettled([promiseFactory(dataItem, i)]))[0];
                                if (d.status === "rejected") {
                                    if (d.reason.e.message === "Not enough funds to send data") {
                                        // sync last good state then stop upload.
                                        if (hasManifest) {
                                            yield this.syncManifest(manifest, manifestPath);
                                        }
                                        throw new Error("Ran out of funds");
                                    }
                                    // console.log(`Error on retry iteration ${i} - ${d.reason}`)
                                    if (i == 3) {
                                        failed[d.reason.i] = d.reason.e;
                                        break outerLoop;
                                    }
                                }
                                else {
                                    pr = d;
                                }
                            }
                        }
                        //only gets here if the promise/upload succeded
                        processed.set(pr.value.id, pr.value.d);
                        if (hasManifest) {
                            // add to manifest
                            const ind = pr.value.i;
                            const it = items[ind];
                            const rel = p.relative(path, it);
                            manifest.paths[rel] = { id: pr.value.d.data.id };
                        }
                    }
                    if (hasManifest) {
                        yield this.syncManifest(manifest, manifestPath);
                    }
                    ; //checkpoint state then start a new block.
                }
                console.log(`Finished deploying ${items.length} Items (${failed.size} failures)`);
                let manifestTx;
                if (hasManifest) {
                    if (failed.size > 0) {
                        console.log("Failures detected - not deploying manifest");
                    }
                    else {
                        const tags = [{ name: "Type", value: "manifest" }, { name: "Content-Type", value: "application/x.arweave-manifest+json" }];
                        manifestTx = yield this.upload(Buffer.from(JSON.stringify(manifest)), tags).catch((e) => { throw new Error(`Failed to deploy manifest: ${e}`); });
                        // console.log(manifestTx.data.id)
                        // console.log(`Manifest ID: ${manifestTx.data.id} `);
                        // console.log("Writing manifest ID to disk")
                        yield fs_1.promises.writeFile(p.join(p.join(path, `${p.sep}..`), `${p.basename(path)}-id.txt`), manifestTx.data.id);
                    }
                }
                //return manifestTx.data.id;
                return { processed, failed, manifestTx: manifestTx === null || manifestTx === void 0 ? void 0 : manifestTx.data.id };
            }
            catch (err) {
                console.log(`Error whilst deploying: ${err} `);
                yield this.syncManifest(manifest, manifestPath);
                return { processed, failed };
            }
        });
    }
    /**
     * Uploads a given dataItem to the bundler
     * @param dataItem
     */
    dataItemUploader(dataItem) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const { protocol, host, port } = this.api.getConfig();
            const res = yield this.api.post(`${protocol}://${host}:${port}/tx/${this.currency}`, dataItem.getRaw(), {
                headers: { "Content-Type": "application/octet-stream", },
                timeout: 100000,
                maxBodyLength: Infinity,
                validateStatus: (status) => (status > 202 && status < 300) || status !== 402
            });
            if (res.status === 402) {
                throw new Error("Not enough funds to send data");
            }
            return res;
        });
    }
    syncManifest(manifest, manifestPath) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            fs_1.promises.writeFile(manifestPath, Buffer.from(JSON.stringify(manifest))).catch(e => {
                console.log(`Error syncing manifest: ${e}`);
            }); //.finally(() => {
            //     this.syncMutex = false
            // });
        });
    }
}
exports.default = Uploader;
//# sourceMappingURL=upload.js.map