module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 25);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/defineProperty");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/assertThisInitialized");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/regenerator");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/asyncToGenerator");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("@toruslabs/openlogin-jrpc");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/getPrototypeOf");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("eth-rpc-errors");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/classCallCheck");

/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/createClass");

/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/get");

/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = require("@toruslabs/http-helpers");

/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/inherits");

/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/possibleConstructorReturn");

/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/typeof");

/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = require("pump");

/***/ }),
/* 15 */
/***/ (function(module, exports) {

module.exports = require("@toruslabs/torus.js");

/***/ }),
/* 16 */
/***/ (function(module, exports) {

module.exports = require("@metamask/obs-store");

/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/objectWithoutProperties");

/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = require("@toruslabs/fetch-node-details");

/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = require("lodash.merge");

/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = require("fast-deep-equal");

/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = require("is-stream");

/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = require("loglevel");

/***/ }),
/* 23 */
/***/ (function(module, exports) {

module.exports = require("create-hash");

/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "default", function() { return /* reexport */ src_embed; });
__webpack_require__.d(__webpack_exports__, "TorusInpageProvider", function() { return /* reexport */ inpage_provider; });
__webpack_require__.d(__webpack_exports__, "LOGIN_PROVIDER", function() { return /* reexport */ LOGIN_PROVIDER; });
__webpack_require__.d(__webpack_exports__, "WALLET_OPENLOGIN_VERIFIER_MAP", function() { return /* reexport */ WALLET_OPENLOGIN_VERIFIER_MAP; });
__webpack_require__.d(__webpack_exports__, "PAYMENT_PROVIDER", function() { return /* reexport */ PAYMENT_PROVIDER; });
__webpack_require__.d(__webpack_exports__, "TORUS_BUILD_ENV", function() { return /* reexport */ TORUS_BUILD_ENV; });
__webpack_require__.d(__webpack_exports__, "BUTTON_POSITION", function() { return /* reexport */ BUTTON_POSITION; });

// EXTERNAL MODULE: external "@babel/runtime/helpers/objectWithoutProperties"
var objectWithoutProperties_ = __webpack_require__(17);
var objectWithoutProperties_default = /*#__PURE__*/__webpack_require__.n(objectWithoutProperties_);

// EXTERNAL MODULE: external "@babel/runtime/helpers/classCallCheck"
var classCallCheck_ = __webpack_require__(7);
var classCallCheck_default = /*#__PURE__*/__webpack_require__.n(classCallCheck_);

// EXTERNAL MODULE: external "@babel/runtime/helpers/createClass"
var createClass_ = __webpack_require__(8);
var createClass_default = /*#__PURE__*/__webpack_require__.n(createClass_);

// EXTERNAL MODULE: external "@babel/runtime/helpers/asyncToGenerator"
var asyncToGenerator_ = __webpack_require__(3);
var asyncToGenerator_default = /*#__PURE__*/__webpack_require__.n(asyncToGenerator_);

// EXTERNAL MODULE: external "@babel/runtime/helpers/defineProperty"
var defineProperty_ = __webpack_require__(0);
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty_);

// EXTERNAL MODULE: external "@babel/runtime/regenerator"
var regenerator_ = __webpack_require__(2);
var regenerator_default = /*#__PURE__*/__webpack_require__.n(regenerator_);

// EXTERNAL MODULE: external "@toruslabs/fetch-node-details"
var fetch_node_details_ = __webpack_require__(18);
var fetch_node_details_default = /*#__PURE__*/__webpack_require__.n(fetch_node_details_);

// EXTERNAL MODULE: external "@toruslabs/http-helpers"
var http_helpers_ = __webpack_require__(10);

// EXTERNAL MODULE: external "@toruslabs/openlogin-jrpc"
var openlogin_jrpc_ = __webpack_require__(4);

// EXTERNAL MODULE: external "@toruslabs/torus.js"
var torus_js_ = __webpack_require__(15);
var torus_js_default = /*#__PURE__*/__webpack_require__.n(torus_js_);

// EXTERNAL MODULE: external "lodash.merge"
var external_lodash_merge_ = __webpack_require__(19);
var external_lodash_merge_default = /*#__PURE__*/__webpack_require__.n(external_lodash_merge_);

// CONCATENATED MODULE: ./src/interfaces.ts


var _WALLET_OPENLOGIN_VER;

var LOGIN_PROVIDER = {
  GOOGLE: "google",
  FACEBOOK: "facebook",
  TWITCH: "twitch",
  REDDIT: "reddit",
  DISCORD: "discord"
};
var WALLET_OPENLOGIN_VERIFIER_MAP = (_WALLET_OPENLOGIN_VER = {}, defineProperty_default()(_WALLET_OPENLOGIN_VER, LOGIN_PROVIDER.GOOGLE, "tkey-google"), defineProperty_default()(_WALLET_OPENLOGIN_VER, LOGIN_PROVIDER.FACEBOOK, "tkey-facebook"), defineProperty_default()(_WALLET_OPENLOGIN_VER, LOGIN_PROVIDER.TWITCH, "tkey-twitch"), defineProperty_default()(_WALLET_OPENLOGIN_VER, LOGIN_PROVIDER.REDDIT, "tkey-reddit"), defineProperty_default()(_WALLET_OPENLOGIN_VER, LOGIN_PROVIDER.DISCORD, "tkey-discord"), _WALLET_OPENLOGIN_VER);
var PAYMENT_PROVIDER = {
  MOONPAY: "moonpay",
  WYRE: "wyre",
  RAMPNETWORK: "rampnetwork",
  XANPOOL: "xanpool",
  MERCURYO: "mercuryo",
  TRANSAK: "transak"
};
var TORUS_BUILD_ENV = {
  PRODUCTION: "production",
  DEVELOPMENT: "development",
  BINANCE: "binance",
  TESTING: "testing",
  LRC: "lrc",
  BETA: "beta"
};
var BUTTON_POSITION = {
  BOTTOM_LEFT: "bottom-left",
  TOP_LEFT: "top-left",
  BOTTOM_RIGHT: "bottom-right",
  TOP_RIGHT: "top-right"
};
// CONCATENATED MODULE: ./src/config.ts


var _paymentProviders;


var paymentProviders = (_paymentProviders = {}, defineProperty_default()(_paymentProviders, PAYMENT_PROVIDER.RAMPNETWORK, {
  line1: "Debit Card/ Apple Pay/ Bank transfer",
  line2: "0.49% - 2.9%",
  line3: "5,000€/purchase, 20,000€/mo",
  supportPage: "https://instant.ramp.network/",
  minOrderValue: 50,
  maxOrderValue: 20000,
  validCurrencies: ["GBP", "EUR", "USD"],
  validCryptoCurrencies: ["ETH", "DAI", "USDC", "BSC_BNB"],
  includeFees: true,
  enforceMax: false
}), defineProperty_default()(_paymentProviders, PAYMENT_PROVIDER.MOONPAY, {
  line1: "Credit / Debit Card / Apple Pay",
  line2: "4.5% or 5 USD",
  line3: "2,000€/day, 10,000€/mo",
  supportPage: "https://help.moonpay.io/en/",
  minOrderValue: 24.99,
  maxOrderValue: 50000,
  validCurrencies: ["USD", "EUR", "GBP", "AUD", "CAD", "SGD", "RUB"],
  validCryptoCurrencies: ["ETH", "DAI", "TUSD", "USDC", "USDT", "BNB_BSC", "BUSD_BSC"],
  includeFees: true,
  enforceMax: false
}), defineProperty_default()(_paymentProviders, PAYMENT_PROVIDER.WYRE, {
  line1: "Apple Pay/ Debit/ Credit Card",
  line2: "4.9% + 30¢ or 5 USD",
  line3: "$250/day",
  supportPage: "https://support.sendwyre.com/en/",
  minOrderValue: 5,
  maxOrderValue: 500,
  validCurrencies: ["USD", "AUD", "CAD", "GBP", "EUR"],
  validCryptoCurrencies: ["ETH", "DAI", "USDC", "USDT"],
  includeFees: false,
  enforceMax: false
}), defineProperty_default()(_paymentProviders, PAYMENT_PROVIDER.XANPOOL, {
  line1: "PayNow/ InstaPay/ FPS/ GoJekPay/ UPI/ PromptPay/ VietelPay/ DuitNow",
  line2: "2.5% buying, 3% selling",
  line3: "$2,500 / day",
  supportPage: "mailto:support@xanpool.com",
  minOrderValue: 100,
  maxOrderValue: 2500,
  validCurrencies: ["SGD", "HKD", "MYR", "PHP", "INR", "VND", "THB", "IDR"],
  validCryptoCurrencies: ["ETH", "USDT"],
  includeFees: true,
  sell: true,
  enforceMax: false
}), defineProperty_default()(_paymentProviders, PAYMENT_PROVIDER.MERCURYO, {
  line1: "Credit/ Debit Card/ Apple Pay",
  line2: "3.95% or 4 USD",
  line3: "10,000€/day, 25,000€/mo",
  supportPage: "mailto:support@mercuryo.io",
  minOrderValue: 30,
  maxOrderValue: 5000,
  validCurrencies: ["USD", "EUR", "RUB", "TRY", "GBP", "UAH"],
  validCryptoCurrencies: ["ETH", "DAI", "BAT", "USDT", "OKB"],
  includeFees: true,
  enforceMax: false
}), defineProperty_default()(_paymentProviders, PAYMENT_PROVIDER.TRANSAK, {
  line1: "Credit/ Debit Card/ <br/>Bank Transfer (sepa/gbp)",
  line2: "0.99% - 5.5% or 5 USD",
  line3: "500€/day",
  supportPage: "https://support.transak.com/hc/en-US",
  minOrderValue: 20,
  maxOrderValue: 500,
  validCurrencies: ["USD", "EUR", "GBP", "AUD", "CAD", "SGD"],
  validCryptoCurrencies: ["ETH", "DAI", "USDC", "USDT"],
  includeFees: true,
  enforceMax: false
}), _paymentProviders);
var translations = {
  en: {
    embed: {
      continue: "Continue",
      actionRequired: "Authorization required",
      pendingAction: "Click continue to proceed with your request in a popup",
      cookiesRequired: "Cookies Required",
      enableCookies: "Please enable cookies in your browser preferences to access Torus",
      clickHere: "More Info"
    }
  },
  de: {
    embed: {
      continue: "Fortsetzen",
      actionRequired: "Autorisierung erforderlich",
      pendingAction: "Klicken Sie in einem Popup auf Weiter, um mit Ihrer Anfrage fortzufahren",
      cookiesRequired: "Cookies benötigt",
      enableCookies: "Bitte aktivieren Sie Cookies in Ihren Browsereinstellungen, um auf Torus zuzugreifen",
      clickHere: "Mehr Info"
    }
  },
  ja: {
    embed: {
      continue: "継続する",
      actionRequired: "認証が必要です",
      pendingAction: "続行をクリックして、ポップアップでリクエストを続行します",
      cookiesRequired: "必要なクッキー",
      enableCookies: "Torusにアクセスするには、ブラウザの設定でCookieを有効にしてください。",
      clickHere: "詳しくは"
    }
  },
  ko: {
    embed: {
      continue: "계속하다",
      actionRequired: "승인 필요",
      pendingAction: "팝업에서 요청을 진행하려면 계속을 클릭하십시오.",
      cookiesRequired: "쿠키 필요",
      enableCookies: "브라우저 환경 설정에서 쿠키를 활성화하여 Torus에 액세스하십시오.",
      clickHere: "더 많은 정보"
    }
  },
  zh: {
    embed: {
      continue: "继续",
      actionRequired: "需要授权",
      pendingAction: "单击继续以在弹出窗口中继续您的请求",
      cookiesRequired: "必填Cookie",
      enableCookies: "请在您的浏览器首选项中启用cookie以访问Torus。",
      clickHere: "更多信息"
    }
  }
};
/* harmony default export */ var config = ({
  supportedVerifierList: [LOGIN_PROVIDER.GOOGLE, LOGIN_PROVIDER.REDDIT, LOGIN_PROVIDER.DISCORD],
  paymentProviders: paymentProviders,
  api: "https://api.tor.us",
  translations: translations,
  prodTorusUrl: "",
  localStorageKey: "torus-".concat(window.location.hostname)
});
// CONCATENATED MODULE: ./src/embedUtils.ts


var runOnLoad = function runOnLoad(fn) {
  return new Promise(function (resolve, reject) {
    if (window.document.body != null) {
      Promise.resolve(fn()).then(resolve).catch(reject);
    } else {
      window.document.addEventListener("DOMContentLoaded", function () {
        Promise.resolve(fn()).then(resolve).catch(reject);
      });
    }
  });
};
var runOnComplete = function runOnComplete(fn) {
  var retry = window.setInterval(function () {
    if (window.document.readyState === "complete") {
      window.clearInterval(retry);
      fn();
    }
  }, 300);
};
var htmlToElement = function htmlToElement(html) {
  var template = window.document.createElement("template");
  var trimmedHtml = html.trim(); // Never return a text node of whitespace as the result

  template.innerHTML = trimmedHtml;
  return template.content.firstChild;
};
var handleEvent = function handleEvent(handle, eventName, handler) {
  for (var _len = arguments.length, handlerArgs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
    handlerArgs[_key - 3] = arguments[_key];
  }

  var handlerWrapper = function handlerWrapper() {
    handler.apply(void 0, handlerArgs);
    handle.removeEventListener(eventName, handlerWrapper);
  };

  handle.addEventListener(eventName, handlerWrapper);
};
var handleStream = function handleStream(handle, eventName, handler) {
  var handlerWrapper = function handlerWrapper(chunk) {
    handler(chunk);
    handle.removeListener(eventName, handlerWrapper);
  };

  handle.on(eventName, handlerWrapper);
};
function documentReady() {
  return _documentReady.apply(this, arguments);
}

function _documentReady() {
  _documentReady = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee() {
    return regenerator_default.a.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", new Promise(function (resolve) {
              if (document.readyState !== "loading") {
                resolve();
              } else {
                handleEvent(document, "DOMContentLoaded", resolve);
              }
            }));

          case 1:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _documentReady.apply(this, arguments);
}
// EXTERNAL MODULE: external "@babel/runtime/helpers/typeof"
var typeof_ = __webpack_require__(13);
var typeof_default = /*#__PURE__*/__webpack_require__.n(typeof_);

// EXTERNAL MODULE: external "@babel/runtime/helpers/assertThisInitialized"
var assertThisInitialized_ = __webpack_require__(1);
var assertThisInitialized_default = /*#__PURE__*/__webpack_require__.n(assertThisInitialized_);

// EXTERNAL MODULE: external "@babel/runtime/helpers/get"
var get_ = __webpack_require__(9);
var get_default = /*#__PURE__*/__webpack_require__.n(get_);

// EXTERNAL MODULE: external "@babel/runtime/helpers/inherits"
var inherits_ = __webpack_require__(11);
var inherits_default = /*#__PURE__*/__webpack_require__.n(inherits_);

// EXTERNAL MODULE: external "@babel/runtime/helpers/possibleConstructorReturn"
var possibleConstructorReturn_ = __webpack_require__(12);
var possibleConstructorReturn_default = /*#__PURE__*/__webpack_require__.n(possibleConstructorReturn_);

// EXTERNAL MODULE: external "@babel/runtime/helpers/getPrototypeOf"
var getPrototypeOf_ = __webpack_require__(5);
var getPrototypeOf_default = /*#__PURE__*/__webpack_require__.n(getPrototypeOf_);

// EXTERNAL MODULE: external "@metamask/obs-store"
var obs_store_ = __webpack_require__(16);

// EXTERNAL MODULE: external "eth-rpc-errors"
var external_eth_rpc_errors_ = __webpack_require__(6);

// EXTERNAL MODULE: external "fast-deep-equal"
var external_fast_deep_equal_ = __webpack_require__(20);
var external_fast_deep_equal_default = /*#__PURE__*/__webpack_require__.n(external_fast_deep_equal_);

// EXTERNAL MODULE: external "is-stream"
var external_is_stream_ = __webpack_require__(21);

// EXTERNAL MODULE: external "pump"
var external_pump_ = __webpack_require__(14);
var external_pump_default = /*#__PURE__*/__webpack_require__.n(external_pump_);

// EXTERNAL MODULE: external "loglevel"
var external_loglevel_ = __webpack_require__(22);
var external_loglevel_default = /*#__PURE__*/__webpack_require__.n(external_loglevel_);

// CONCATENATED MODULE: ./src/loglevel.ts

/* harmony default export */ var loglevel = (external_loglevel_default.a.getLogger("torus-embed"));
// CONCATENATED MODULE: ./src/messages.ts
/* harmony default export */ var messages = ({
  errors: {
    disconnected: function disconnected() {
      return "Torus: Lost connection to Torus.";
    },
    permanentlyDisconnected: function permanentlyDisconnected() {
      return "Torus: Disconnected from iframe. Page reload required.";
    },
    sendSiteMetadata: function sendSiteMetadata() {
      return "Torus: Failed to send site metadata. This is an internal error, please report this bug.";
    },
    unsupportedSync: function unsupportedSync(method) {
      return "Torus: The Torus Ethereum provider does not support synchronous methods like ".concat(method, " without a callback parameter.");
    },
    invalidDuplexStream: function invalidDuplexStream() {
      return "Must provide a Node.js-style duplex stream.";
    },
    invalidOptions: function invalidOptions(maxEventListeners, shouldSendMetadata) {
      return "Invalid options. Received: { maxEventListeners: ".concat(maxEventListeners, ", shouldSendMetadata: ").concat(shouldSendMetadata, " }");
    },
    invalidRequestArgs: function invalidRequestArgs() {
      return "Expected a single, non-array, object argument.";
    },
    invalidRequestMethod: function invalidRequestMethod() {
      return "'args.method' must be a non-empty string.";
    },
    invalidRequestParams: function invalidRequestParams() {
      return "'args.params' must be an object or array if provided.";
    },
    invalidLoggerObject: function invalidLoggerObject() {
      return "'args.logger' must be an object if provided.";
    },
    invalidLoggerMethod: function invalidLoggerMethod(method) {
      return "'args.logger' must include required method '".concat(method, "'.");
    }
  },
  info: {
    connected: function connected(chainId) {
      return "Torus: Connected to chain with ID \"".concat(chainId, "\".");
    }
  },
  warnings: {
    // deprecated methods
    enableDeprecation: 'Torus: ""ethereum.enable()" is deprecated and may be removed in the future. ' + 'Please use "ethereum.send("eth_requestAccounts")" instead. For more information, see: https://eips.ethereum.org/EIPS/eip-1102',
    sendDeprecation: 'Torus: "ethereum.send(...)" is deprecated and may be removed in the future.' + ' Please use "ethereum.sendAsync(...)" or "ethereum.request(...)" instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193',
    events: {
      close: 'Torus: The event "close" is deprecated and may be removed in the future. Please use "disconnect" instead.' + "\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193",
      data: 'Torus: The event "data" is deprecated and will be removed in the future.' + 'Use "message" instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#message',
      networkChanged: 'Torus: The event "networkChanged" is deprecated and may be removed in the future.' + ' Please use "chainChanged" instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193',
      notification: 'Torus: The event "notification" is deprecated and may be removed in the future. ' + 'Please use "message" instead.\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193'
    },
    publicConfigStore: 'Torus: The property "publicConfigStore" is deprecated and WILL be removed in the future.'
  }
});
// CONCATENATED MODULE: ./src/utils.ts






var utils_paymentProviders = config.paymentProviders;
var validatePaymentProvider = function validatePaymentProvider(provider, params) {
  var errors = {};

  if (!provider) {
    return {
      errors: errors,
      isValid: true
    };
  }

  if (provider && !utils_paymentProviders[provider]) {
    errors.provider = "Invalid Provider";
    return {
      errors: errors,
      isValid: Object.keys(errors).length === 0
    };
  }

  var selectedProvider = utils_paymentProviders[provider];
  var selectedParams = params || {}; // set default values
  // if (!selectedParams.selectedCurrency) [selectedParams.selectedCurrency] = selectedProvider.validCurrencies
  // if (!selectedParams.fiatValue) selectedParams.fiatValue = selectedProvider.minOrderValue
  // if (!selectedParams.selectedCryptoCurrency) [selectedParams.selectedCryptoCurrency] = selectedProvider.validCryptoCurrencies
  // validations

  if (selectedParams.fiatValue) {
    var requestedOrderAmount = +parseFloat(selectedParams.fiatValue.toString()) || 0;
    if (requestedOrderAmount < selectedProvider.minOrderValue) errors.fiatValue = "Requested amount is lower than supported";
    if (requestedOrderAmount > selectedProvider.maxOrderValue && selectedProvider.enforceMax) errors.fiatValue = "Requested amount is higher than supported";
  }

  if (selectedParams.selectedCurrency && !selectedProvider.validCurrencies.includes(selectedParams.selectedCurrency)) {
    errors.selectedCurrency = "Unsupported currency";
  }

  if (selectedParams.selectedCryptoCurrency && !selectedProvider.validCryptoCurrencies.includes(selectedParams.selectedCryptoCurrency)) {
    errors.selectedCryptoCurrency = "Unsupported cryptoCurrency";
  }

  return {
    errors: errors,
    isValid: Object.keys(errors).length === 0
  };
}; // utility functions

/**
 * json-rpc-engine middleware that logs RPC errors and and validates req.method.
 *
 * @param log - The logging API to use.
 * @returns  json-rpc-engine middleware function
 */

function createErrorMiddleware() {
  return function (req, res, next) {
    // json-rpc-engine will terminate the request when it notices this error
    if (typeof req.method !== "string" || !req.method) {
      res.error = external_eth_rpc_errors_["ethErrors"].rpc.invalidRequest({
        message: "The request 'method' must be a non-empty string.",
        data: req
      });
    }

    next(function (done) {
      var error = res.error;

      if (!error) {
        return done();
      }

      loglevel.error("MetaMask - RPC Error: ".concat(error.message), error);
      return done();
    });
  };
} // resolve response.result or response, reject errors

var getRpcPromiseCallback = function getRpcPromiseCallback(resolve, reject) {
  var unwrapResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  return function (error, response) {
    if (error || response.error) {
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      reject(error || response.error);
    } else {
      resolve(!unwrapResult || Array.isArray(response) ? response : response.result);
    }
  };
};
/**
 * Logs a stream disconnection error. Emits an 'error' if given an
 * EventEmitter that has listeners for the 'error' event.
 *
 * @param log - The logging API to use.
 * @param remoteLabel - The label of the disconnected stream.
 * @param error - The associated error to log.
 * @param emitter - The logging API to use.
 */

function logStreamDisconnectWarning(remoteLabel, error, emitter) {
  var warningMsg = "MetaMask: Lost connection to \"".concat(remoteLabel, "\".");

  if (error !== null && error !== void 0 && error.stack) {
    warningMsg += "\n".concat(error.stack);
  }

  loglevel.warn(warningMsg);

  if (emitter && emitter.listenerCount("error") > 0) {
    emitter.emit("error", warningMsg);
  }
}
var getPreopenInstanceId = function getPreopenInstanceId() {
  return Math.random().toString(36).slice(2);
};
var getTorusUrl = /*#__PURE__*/function () {
  var _ref = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee(buildEnv, integrity) {
    var torusUrl, logLevel, version, versionUsed, response;
    return regenerator_default.a.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            // Do not change this line
            version = "1.18.5";
            versionUsed = integrity.version || version;
            _context.prev = 2;

            if (!((buildEnv === "binance" || buildEnv === "production") && !integrity.version)) {
              _context.next = 13;
              break;
            }

            if (config.prodTorusUrl) {
              _context.next = 10;
              break;
            }

            _context.next = 7;
            return Object(http_helpers_["get"])("".concat(config.api, "/latestversion?name=@toruslabs/torus-embed&version=").concat(version), {}, {
              useAPIKey: true
            });

          case 7:
            response = _context.sent;
            _context.next = 11;
            break;

          case 10:
            response = {
              data: config.prodTorusUrl
            };

          case 11:
            versionUsed = response.data; // eslint-disable-next-line require-atomic-updates

            config.prodTorusUrl = response.data;

          case 13:
            _context.next = 18;
            break;

          case 15:
            _context.prev = 15;
            _context.t0 = _context["catch"](2);
            loglevel.error(_context.t0, "unable to fetch latest version");

          case 18:
            loglevel.info("version used: ", versionUsed);
            _context.t1 = buildEnv;
            _context.next = _context.t1 === "binance" ? 22 : _context.t1 === "testing" ? 25 : _context.t1 === "lrc" ? 28 : _context.t1 === "beta" ? 31 : _context.t1 === "development" ? 34 : 37;
            break;

          case 22:
            torusUrl = "https://binance.tor.us/v".concat(versionUsed);
            logLevel = "info";
            return _context.abrupt("break", 40);

          case 25:
            torusUrl = "https://testing.tor.us";
            logLevel = "debug";
            return _context.abrupt("break", 40);

          case 28:
            torusUrl = "https://lrc.tor.us";
            logLevel = "debug";
            return _context.abrupt("break", 40);

          case 31:
            torusUrl = "https://beta.tor.us";
            logLevel = "debug";
            return _context.abrupt("break", 40);

          case 34:
            torusUrl = "http://localhost:4050";
            logLevel = "debug";
            return _context.abrupt("break", 40);

          case 37:
            torusUrl = "https://app.tor.us/v".concat(versionUsed);
            logLevel = "error";
            return _context.abrupt("break", 40);

          case 40:
            return _context.abrupt("return", {
              torusUrl: torusUrl,
              logLevel: logLevel
            });

          case 41:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[2, 15]]);
  }));

  return function getTorusUrl(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
var utils_getUserLanguage = function getUserLanguage() {
  var userLanguage = window.navigator.language || "en-US";
  var userLanguages = userLanguage.split("-");
  userLanguage = Object.prototype.hasOwnProperty.call(config.translations, userLanguages[0]) ? userLanguages[0] : "en";
  return userLanguage;
};
var EMITTED_NOTIFICATIONS = ["eth_subscription" // per eth-json-rpc-filters/subscriptionManager
];
var NOOP = function NOOP() {// empty function
};
var FEATURES_PROVIDER_CHANGE_WINDOW = "directories=0,titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=660,width=375";
var FEATURES_DEFAULT_WALLET_WINDOW = "directories=0,titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=740,width=1315";
var FEATURES_DEFAULT_POPUP_WINDOW = "directories=0,titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=700,width=1200";
var FEATURES_CONFIRM_WINDOW = "directories=0,titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=700,width=450";
function storageAvailable(type) {
  var storage;

  try {
    storage = window[type];
    var x = "__storage_test__";
    storage.setItem(x, x);
    storage.removeItem(x);
    return true;
  } catch (e) {
    return e && ( // everything except Firefox
    e.code === 22 || // Firefox
    e.code === 1014 || // test name field too, because code might not be present
    // everything except Firefox
    e.name === "QuotaExceededError" || // Firefox
    e.name === "NS_ERROR_DOM_QUOTA_REACHED") && // acknowledge QuotaExceededError only if there's something already stored
    storage && storage.length !== 0;
  }
}
function getPopupFeatures() {
  // Fixes dual-screen position                             Most browsers      Firefox
  var dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : window.screenX;
  var dualScreenTop = window.screenTop !== undefined ? window.screenTop : window.screenY;
  var w = 1200;
  var h = 700;
  var width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : window.screen.width;
  var height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : window.screen.height;
  var systemZoom = 1; // No reliable estimate

  var left = Math.abs((width - w) / 2 / systemZoom + dualScreenLeft);
  var top = Math.abs((height - h) / 2 / systemZoom + dualScreenTop);
  var features = "titlebar=0,toolbar=0,status=0,location=0,menubar=0,height=".concat(h / systemZoom, ",width=").concat(w / systemZoom, ",top=").concat(top, ",left=").concat(left);
  return features;
}
// CONCATENATED MODULE: ./src/inpage-provider.ts











function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }



function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }










openlogin_jrpc_["SafeEventEmitter"].defaultMaxListeners = 100; // resolve response.result, reject errors

var inpage_provider_getRpcPromiseCallback = function getRpcPromiseCallback(resolve, reject) {
  var unwrapResult = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  return function (error, response) {
    if (error || response.error) {
      return reject(error || response.error);
    }

    return !unwrapResult || Array.isArray(response) ? resolve(response) : resolve(response.result);
  };
};

var inpage_provider_TorusInpageProvider = /*#__PURE__*/function (_SafeEventEmitter) {
  inherits_default()(TorusInpageProvider, _SafeEventEmitter);

  var _super = _createSuper(TorusInpageProvider);

  /**
   * The chain ID of the currently connected Ethereum chain.
   * See [chainId.network]{@link https://chainid.network} for more information.
   */

  /**
   * The user's currently selected Ethereum address.
   * If null, MetaMask is either locked or the user has not permitted any
   * addresses to be viewed.
   */

  /**
   * Indicating that this provider is a MetaMask provider.
   */
  function TorusInpageProvider(connectionStream) {
    var _this;

    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$maxEventListener = _ref.maxEventListeners,
        maxEventListeners = _ref$maxEventListener === void 0 ? 100 : _ref$maxEventListener,
        _ref$shouldSendMetada = _ref.shouldSendMetadata,
        shouldSendMetadata = _ref$shouldSendMetada === void 0 ? true : _ref$shouldSendMetada,
        _ref$jsonRpcStreamNam = _ref.jsonRpcStreamName,
        jsonRpcStreamName = _ref$jsonRpcStreamNam === void 0 ? "provider" : _ref$jsonRpcStreamNam;

    classCallCheck_default()(this, TorusInpageProvider);

    _this = _super.call(this);

    defineProperty_default()(assertThisInitialized_default()(_this), "chainId", void 0);

    defineProperty_default()(assertThisInitialized_default()(_this), "selectedAddress", void 0);

    defineProperty_default()(assertThisInitialized_default()(_this), "_rpcEngine", void 0);

    defineProperty_default()(assertThisInitialized_default()(_this), "networkVersion", void 0);

    defineProperty_default()(assertThisInitialized_default()(_this), "shouldSendMetadata", void 0);

    defineProperty_default()(assertThisInitialized_default()(_this), "isTorus", void 0);

    defineProperty_default()(assertThisInitialized_default()(_this), "_publicConfigStore", void 0);

    defineProperty_default()(assertThisInitialized_default()(_this), "tryPreopenHandle", void 0);

    defineProperty_default()(assertThisInitialized_default()(_this), "enable", void 0);

    defineProperty_default()(assertThisInitialized_default()(_this), "_state", void 0);

    defineProperty_default()(assertThisInitialized_default()(_this), "_jsonRpcConnection", void 0);

    defineProperty_default()(assertThisInitialized_default()(_this), "_sentWarnings", {
      // methods
      enable: false,
      experimentalMethods: false,
      send: false,
      publicConfigStore: false,
      // events
      events: {
        close: false,
        data: false,
        networkChanged: false,
        notification: false
      }
    });

    if (!Object(external_is_stream_["isDuplexStream"])(connectionStream)) {
      throw new Error(messages.errors.invalidDuplexStream());
    }

    _this.isTorus = true;

    _this.setMaxListeners(maxEventListeners); // private state


    _this._state = _objectSpread({}, TorusInpageProvider._defaultState); // public state

    _this.selectedAddress = null;
    _this.networkVersion = null;
    _this.chainId = null;
    _this.shouldSendMetadata = shouldSendMetadata; // bind functions (to prevent e.g. web3@1.x from making unbound calls)

    _this._handleAccountsChanged = _this._handleAccountsChanged.bind(assertThisInitialized_default()(_this));
    _this._handleChainChanged = _this._handleChainChanged.bind(assertThisInitialized_default()(_this));
    _this._handleUnlockStateChanged = _this._handleUnlockStateChanged.bind(assertThisInitialized_default()(_this));
    _this._handleConnect = _this._handleConnect.bind(assertThisInitialized_default()(_this));
    _this._handleDisconnect = _this._handleDisconnect.bind(assertThisInitialized_default()(_this));
    _this._handleStreamDisconnect = _this._handleStreamDisconnect.bind(assertThisInitialized_default()(_this));
    _this._sendSync = _this._sendSync.bind(assertThisInitialized_default()(_this));
    _this._rpcRequest = _this._rpcRequest.bind(assertThisInitialized_default()(_this));
    _this._warnOfDeprecation = _this._warnOfDeprecation.bind(assertThisInitialized_default()(_this));
    _this._initializeState = _this._initializeState.bind(assertThisInitialized_default()(_this));
    _this.request = _this.request.bind(assertThisInitialized_default()(_this));
    _this.send = _this.send.bind(assertThisInitialized_default()(_this));
    _this.sendAsync = _this.sendAsync.bind(assertThisInitialized_default()(_this)); // this.enable = this.enable.bind(this);
    // setup connectionStream multiplexing

    var mux = new openlogin_jrpc_["ObjectMultiplex"]();
    external_pump_default()(connectionStream, mux, connectionStream, _this._handleStreamDisconnect.bind(assertThisInitialized_default()(_this), "MetaMask")); // subscribe to metamask public config (one-way)

    _this._publicConfigStore = new obs_store_["ObservableStore"]({
      storageKey: "Metamask-Config"
    }); // handle isUnlocked changes, and chainChanged and networkChanged events
    // this._publicConfigStore.subscribe((stringifiedState) => {
    //   // This is because we are using store as string
    //   const state = JSON.parse(stringifiedState as unknown as string);
    //   if ("isUnlocked" in state && state.isUnlocked !== this._state.isUnlocked) {
    //     this._state.isUnlocked = state.isUnlocked;
    //     if (!this._state.isUnlocked) {
    //       // accounts are never exposed when the extension is locked
    //       this._handleAccountsChanged([]);
    //     } else {
    //       // this will get the exposed accounts, if any
    //       try {
    //         this._rpcRequest(
    //           { method: "eth_accounts", params: [] },
    //           NOOP,
    //           true // indicating that eth_accounts _should_ update accounts
    //         );
    //       } catch (_) {
    //         // Swallow error
    //       }
    //     }
    //   }
    //   if ("selectedAddress" in state && this.selectedAddress !== state.selectedAddress) {
    //     try {
    //       this._rpcRequest(
    //         { method: "eth_accounts", params: [] },
    //         NOOP,
    //         true // indicating that eth_accounts _should_ update accounts
    //       );
    //     } catch (_) {
    //       // Swallow error
    //     }
    //   }
    //   // Emit chainChanged event on chain change
    //   if ("chainId" in state && state.chainId !== this.chainId) {
    //     this.chainId = state.chainId || null;
    //     this.emit("chainChanged", this.chainId);
    //     // indicate that we've connected, for EIP-1193 compliance
    //     // we do this here so that iframe can initialize
    //     if (!this._state.hasEmittedConnection) {
    //       this._handleConnect(this.chainId);
    //       this._state.hasEmittedConnection = true;
    //     }
    //   }
    //   // Emit networkChanged event on network change
    //   if ("networkVersion" in state && state.networkVersion !== this.networkVersion) {
    //     this.networkVersion = state.networkVersion || null;
    //     this.emit("networkChanged", this.networkVersion);
    //   }
    // });

    external_pump_default()(mux.createStream("publicConfig"), Object(obs_store_["storeAsStream"])(_this._publicConfigStore), // RPC requests should still work if only this stream fails
    logStreamDisconnectWarning.bind(assertThisInitialized_default()(_this), "MetaMask PublicConfigStore")); // ignore phishing warning message (handled elsewhere)

    mux.ignoreStream("phishing"); // setup own event listeners
    // EIP-1193 connect

    _this.on("connect", function () {
      _this._state.isConnected = true;
    }); // connect to async provider


    var jsonRpcConnection = Object(openlogin_jrpc_["createStreamMiddleware"])();
    external_pump_default()(jsonRpcConnection.stream, mux.createStream(jsonRpcStreamName), jsonRpcConnection.stream, _this._handleStreamDisconnect.bind(assertThisInitialized_default()(_this), "MetaMask RpcProvider")); // handle RPC requests via dapp-side rpc engine

    var rpcEngine = new openlogin_jrpc_["JRPCEngine"]();
    rpcEngine.push(Object(openlogin_jrpc_["createIdRemapMiddleware"])());
    rpcEngine.push(createErrorMiddleware());
    rpcEngine.push(jsonRpcConnection.middleware);
    _this._rpcEngine = rpcEngine; // json rpc notification listener

    jsonRpcConnection.events.on("notification", function (payload) {
      var method = payload.method,
          params = payload.params;

      if (method === "wallet_accountsChanged") {
        _this._handleAccountsChanged(params);
      } else if (method === "wallet_unlockStateChanged") {
        _this._handleUnlockStateChanged(params);
      } else if (method === "wallet_chainChanged") {
        _this._handleChainChanged(params);
      } else if (EMITTED_NOTIFICATIONS.includes(payload.method)) {
        // EIP 1193 subscriptions, per eth-json-rpc-filters/subscriptionManager
        _this.emit("data", payload); // deprecated


        _this.emit("notification", params.result);

        _this.emit("message", {
          type: method,
          data: params
        });
      } // Backward compatibility for older non EIP 1193 subscriptions
      // this.emit('data', null, payload)

    });
    return _this;
  }

  createClass_default()(TorusInpageProvider, [{
    key: "publicConfigStore",
    get: function get() {
      if (!this._sentWarnings.publicConfigStore) {
        loglevel.warn(messages.warnings.publicConfigStore);
        this._sentWarnings.publicConfigStore = true;
      }

      return this._publicConfigStore;
    }
    /**
     * Returns whether the inpage provider is connected to Torus.
     */

  }, {
    key: "isConnected",
    value: function isConnected() {
      return this._state.isConnected;
    }
    /**
     * Submits an RPC request for the given method, with the given params.
     * Resolves with the result of the method call, or rejects on error.
     *
     * @param args - The RPC request arguments.
     * @returns A Promise that resolves with the result of the RPC method,
     * or rejects if an error is encountered.
     */

  }, {
    key: "request",
    value: function () {
      var _request = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee(args) {
        var _this2 = this;

        var method, params;
        return regenerator_default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(!args || typeof_default()(args) !== "object" || Array.isArray(args))) {
                  _context.next = 2;
                  break;
                }

                throw external_eth_rpc_errors_["ethErrors"].rpc.invalidRequest({
                  message: messages.errors.invalidRequestArgs(),
                  data: args
                });

              case 2:
                method = args.method, params = args.params;

                if (!(typeof method !== "string" || method.length === 0)) {
                  _context.next = 5;
                  break;
                }

                throw external_eth_rpc_errors_["ethErrors"].rpc.invalidRequest({
                  message: messages.errors.invalidRequestMethod(),
                  data: args
                });

              case 5:
                if (!(params !== undefined && !Array.isArray(params) && (typeof_default()(params) !== "object" || params === null))) {
                  _context.next = 7;
                  break;
                }

                throw external_eth_rpc_errors_["ethErrors"].rpc.invalidRequest({
                  message: messages.errors.invalidRequestParams(),
                  data: args
                });

              case 7:
                return _context.abrupt("return", new Promise(function (resolve, reject) {
                  _this2._rpcRequest({
                    method: method,
                    params: params
                  }, inpage_provider_getRpcPromiseCallback(resolve, reject));
                }));

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function request(_x) {
        return _request.apply(this, arguments);
      }

      return request;
    }()
    /**
     * Submits an RPC request per the given JSON-RPC request object.
     *
     * @param payload - The RPC request object.
     * @param cb - The callback function.
     */

  }, {
    key: "sendAsync",
    value: function sendAsync(payload, callback) {
      this._rpcRequest(payload, callback);
    }
    /**
     * We override the following event methods so that we can warn consumers
     * about deprecated events:
     *   addListener, on, once, prependListener, prependOnceListener
     */

  }, {
    key: "addListener",
    value: function addListener(eventName, listener) {
      this._warnOfDeprecation(eventName);

      return get_default()(getPrototypeOf_default()(TorusInpageProvider.prototype), "addListener", this).call(this, eventName, listener);
    }
  }, {
    key: "on",
    value: function on(eventName, listener) {
      this._warnOfDeprecation(eventName);

      return get_default()(getPrototypeOf_default()(TorusInpageProvider.prototype), "on", this).call(this, eventName, listener);
    }
  }, {
    key: "once",
    value: function once(eventName, listener) {
      this._warnOfDeprecation(eventName);

      return get_default()(getPrototypeOf_default()(TorusInpageProvider.prototype), "once", this).call(this, eventName, listener);
    }
  }, {
    key: "prependListener",
    value: function prependListener(eventName, listener) {
      this._warnOfDeprecation(eventName);

      return get_default()(getPrototypeOf_default()(TorusInpageProvider.prototype), "prependListener", this).call(this, eventName, listener);
    }
  }, {
    key: "prependOnceListener",
    value: function prependOnceListener(eventName, listener) {
      this._warnOfDeprecation(eventName);

      return get_default()(getPrototypeOf_default()(TorusInpageProvider.prototype), "prependOnceListener", this).call(this, eventName, listener);
    } // Private Methods
    //= ===================

    /**
     * Constructor helper.
     * Populates initial state by calling 'wallet_getProviderState' and emits
     * necessary events.
     */

  }, {
    key: "_initializeState",
    value: function () {
      var _initializeState2 = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee2() {
        var _ref2, accounts, chainId, isUnlocked, networkVersion;

        return regenerator_default.a.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.prev = 0;
                _context2.next = 3;
                return this.request({
                  method: "wallet_getProviderState"
                });

              case 3:
                _ref2 = _context2.sent;
                accounts = _ref2.accounts;
                chainId = _ref2.chainId;
                isUnlocked = _ref2.isUnlocked;
                networkVersion = _ref2.networkVersion;
                // indicate that we've connected, for EIP-1193 compliance
                this.emit("connect", {
                  chainId: chainId
                });

                this._handleChainChanged({
                  chainId: chainId,
                  networkVersion: networkVersion
                });

                this._handleUnlockStateChanged({
                  accounts: accounts,
                  isUnlocked: isUnlocked
                });

                this._handleAccountsChanged(accounts);

                _context2.next = 17;
                break;

              case 14:
                _context2.prev = 14;
                _context2.t0 = _context2["catch"](0);
                loglevel.error("MetaMask: Failed to get initial state. Please report this bug.", _context2.t0);

              case 17:
                _context2.prev = 17;
                loglevel.info("initialized state");
                this._state.initialized = true;
                this.emit("_initialized");
                return _context2.finish(17);

              case 22:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this, [[0, 14, 17, 22]]);
      }));

      function _initializeState() {
        return _initializeState2.apply(this, arguments);
      }

      return _initializeState;
    }()
    /**
     * Internal RPC method. Forwards requests to background via the RPC engine.
     * Also remap ids inbound and outbound.
     *
     * @param payload - The RPC request object.
     * @param callback - The consumer's callback.
     * @param isInternal - false - Whether the request is internal.
     */

  }, {
    key: "_rpcRequest",
    value: function _rpcRequest(payload, callback) {
      var _this3 = this;

      var isInternal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var cb = callback;
      var _payload = payload;

      if (!Array.isArray(_payload)) {
        if (!_payload.jsonrpc) {
          _payload.jsonrpc = "2.0";
        }

        if (_payload.method === "eth_accounts" || _payload.method === "eth_requestAccounts") {
          // handle accounts changing
          cb = function cb(err, res) {
            _this3._handleAccountsChanged(res.result || [], _payload.method === "eth_accounts", isInternal);

            callback(err, res);
          };
        } else if (_payload.method === "wallet_getProviderState") {
          this._rpcEngine.handle(payload, cb);

          return;
        }
      }

      this.tryPreopenHandle(_payload, cb);
    }
    /**
     * Submits an RPC request for the given method, with the given params.
     *
     * @deprecated Use "request" instead.
     * @param method - The method to request.
     * @param params - Any params for the method.
     * @returns A Promise that resolves with the JSON-RPC response object for the
     * request.
     */

  }, {
    key: "send",
    value: function send(methodOrPayload, callbackOrArgs) {
      var _this4 = this;

      if (!this._sentWarnings.send) {
        loglevel.warn(messages.warnings.sendDeprecation);
        this._sentWarnings.send = true;
      }

      if (typeof methodOrPayload === "string" && (!callbackOrArgs || Array.isArray(callbackOrArgs))) {
        return new Promise(function (resolve, reject) {
          try {
            _this4._rpcRequest({
              method: methodOrPayload,
              params: callbackOrArgs
            }, inpage_provider_getRpcPromiseCallback(resolve, reject, false));
          } catch (error) {
            reject(error);
          }
        });
      }

      if (methodOrPayload && typeof_default()(methodOrPayload) === "object" && typeof callbackOrArgs === "function") {
        return this._rpcRequest(methodOrPayload, callbackOrArgs);
      }

      return this._sendSync(methodOrPayload);
    }
    /**
     * DEPRECATED.
     * Internal backwards compatibility method, used in send.
     */

  }, {
    key: "_sendSync",
    value: function _sendSync(payload) {
      var result;

      switch (payload.method) {
        case "eth_accounts":
          result = this.selectedAddress ? [this.selectedAddress] : [];
          break;

        case "eth_coinbase":
          result = this.selectedAddress || null;
          break;

        case "eth_uninstallFilter":
          this._rpcRequest(payload, NOOP);

          result = true;
          break;

        case "net_version":
          result = this.networkVersion || null;
          break;

        default:
          throw new Error(messages.errors.unsupportedSync(payload.method));
      }

      return {
        id: payload.id,
        jsonrpc: payload.jsonrpc,
        result: result
      };
    }
    /**
     * When the provider becomes connected, updates internal state and emits
     * required events. Idempotent.
     *
     * @param chainId - The ID of the newly connected chain.
     * emits MetaMaskInpageProvider#connect
     */

  }, {
    key: "_handleConnect",
    value: function _handleConnect(chainId) {
      if (!this._state.isConnected) {
        this._state.isConnected = true;
        this.emit("connect", {
          chainId: chainId
        });
        loglevel.debug(messages.info.connected(chainId));
      }
    }
    /**
     * When the provider becomes disconnected, updates internal state and emits
     * required events. Idempotent with respect to the isRecoverable parameter.
     *
     * Error codes per the CloseEvent status codes as required by EIP-1193:
     * https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
     *
     * @param isRecoverable - Whether the disconnection is recoverable.
     * @param errorMessage - A custom error message.
     * emits MetaMaskInpageProvider#disconnect
     */

  }, {
    key: "_handleDisconnect",
    value: function _handleDisconnect(isRecoverable, errorMessage) {
      if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !isRecoverable) {
        this._state.isConnected = false;

        var _error;

        if (isRecoverable) {
          _error = new external_eth_rpc_errors_["EthereumRpcError"](1013, // Try again later
          errorMessage || messages.errors.disconnected());
          loglevel.debug(_error);
        } else {
          _error = new external_eth_rpc_errors_["EthereumRpcError"](1011, // Internal error
          errorMessage || messages.errors.permanentlyDisconnected());
          loglevel.error(_error);
          this.chainId = null;
          this._state.accounts = null;
          this.selectedAddress = null;
          this._state.isUnlocked = false;
          this._state.isPermanentlyDisconnected = true;
        }

        this.emit("disconnect", _error);
      }
    }
    /**
     * Called when connection is lost to critical streams.
     *
     * emits MetamaskInpageProvider#disconnect
     */

  }, {
    key: "_handleStreamDisconnect",
    value: function _handleStreamDisconnect(streamName, error) {
      logStreamDisconnectWarning(streamName, error, this);

      this._handleDisconnect(false, error ? error.message : undefined);
    }
    /**
     * Called when accounts may have changed.
     */

  }, {
    key: "_handleAccountsChanged",
    value: function _handleAccountsChanged(accounts) {
      var isEthAccounts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var isInternal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      // defensive programming
      var finalAccounts = accounts;

      if (!Array.isArray(finalAccounts)) {
        loglevel.error("MetaMask: Received non-array accounts parameter. Please report this bug.", finalAccounts);
        finalAccounts = [];
      }

      var _iterator = _createForOfIteratorHelper(accounts),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var account = _step.value;

          if (typeof account !== "string") {
            loglevel.error("MetaMask: Received non-string account. Please report this bug.", accounts);
            finalAccounts = [];
            break;
          }
        } // emit accountsChanged if anything about the accounts array has changed

      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      if (!external_fast_deep_equal_default()(this._state.accounts, finalAccounts)) {
        // we should always have the correct accounts even before eth_accounts
        // returns, except in cases where isInternal is true
        if (isEthAccounts && Array.isArray(this._state.accounts) && this._state.accounts.length > 0 && !isInternal) {
          loglevel.error('MetaMask: "eth_accounts" unexpectedly updated accounts. Please report this bug.', finalAccounts);
        }

        this._state.accounts = finalAccounts;
        this.emit("accountsChanged", finalAccounts);
      } // handle selectedAddress


      if (this.selectedAddress !== finalAccounts[0]) {
        this.selectedAddress = finalAccounts[0] || null;
      }
    }
    /**
     * Upon receipt of a new chainId and networkVersion, emits corresponding
     * events and sets relevant public state.
     * Does nothing if neither the chainId nor the networkVersion are different
     * from existing values.
     *
     * emits MetamaskInpageProvider#chainChanged
     * @param networkInfo - An object with network info.
     */

  }, {
    key: "_handleChainChanged",
    value: function _handleChainChanged() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          chainId = _ref3.chainId,
          networkVersion = _ref3.networkVersion;

      if (!chainId || !networkVersion) {
        loglevel.error("MetaMask: Received invalid network parameters. Please report this bug.", {
          chainId: chainId,
          networkVersion: networkVersion
        });
        return;
      }

      if (networkVersion === "loading") {
        this._handleDisconnect(true);
      } else {
        this._handleConnect(chainId);

        if (chainId !== this.chainId) {
          this.chainId = chainId;

          if (this._state.initialized) {
            this.emit("chainChanged", this.chainId);
          }
        }
      }
    }
    /**
     * Upon receipt of a new isUnlocked state, sets relevant public state.
     * Calls the accounts changed handler with the received accounts, or an empty
     * array.
     *
     * Does nothing if the received value is equal to the existing value.
     * There are no lock/unlock events.
     *
     * @param opts - Options bag.
     */

  }, {
    key: "_handleUnlockStateChanged",
    value: function _handleUnlockStateChanged() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          accounts = _ref4.accounts,
          isUnlocked = _ref4.isUnlocked;

      if (typeof isUnlocked !== "boolean") {
        loglevel.error("MetaMask: Received invalid isUnlocked parameter. Please report this bug.", {
          isUnlocked: isUnlocked
        });
        return;
      }

      if (isUnlocked !== this._state.isUnlocked) {
        this._state.isUnlocked = isUnlocked;

        this._handleAccountsChanged(accounts || []);
      }
    }
    /**
     * Warns of deprecation for the given event, if applicable.
     */

  }, {
    key: "_warnOfDeprecation",
    value: function _warnOfDeprecation(eventName) {
      if (this._sentWarnings.events[eventName] === false) {
        loglevel.warn(messages.warnings.events[eventName]);
        this._sentWarnings.events[eventName] = true;
      }
    }
  }]);

  return TorusInpageProvider;
}(openlogin_jrpc_["SafeEventEmitter"]);

defineProperty_default()(inpage_provider_TorusInpageProvider, "_defaultState", {
  accounts: null,
  isConnected: false,
  isUnlocked: false,
  initialized: false,
  isPermanentlyDisconnected: false,
  hasEmittedConnection: false
});

/* harmony default export */ var inpage_provider = (inpage_provider_TorusInpageProvider);
// EXTERNAL MODULE: external "create-hash"
var external_create_hash_ = __webpack_require__(23);
var external_create_hash_default = /*#__PURE__*/__webpack_require__.n(external_create_hash_);

// CONCATENATED MODULE: ./src/integrity.ts


var defaults = function defaults(options) {
  return {
    algorithms: options.algorithms || ["sha256"],
    delimiter: options.delimiter || " ",
    full: options.full || false
  };
}; // Generate list of hashes


var integrity_hashes = function hashes(options, data) {
  var internalHashes = {};
  options.algorithms.forEach(function (algorithm) {
    internalHashes[algorithm] = external_create_hash_default()(algorithm).update(data, "utf8").digest("base64");
  });
  return internalHashes;
}; // Build an integrity string


var integrity_integrity = function integrity(options, sri) {
  var output = ""; // Hash list

  output += Object.keys(sri.hashes).map(function (algorithm) {
    return "".concat(algorithm, "-").concat(sri.hashes[algorithm]);
  }).join(options.delimiter);
  return output;
};

var main = function main(options, data) {
  // Defaults
  var finalOptions = defaults(options);
  var sri = {
    hashes: integrity_hashes(finalOptions, data),
    integrity: undefined
  };
  sri.integrity = integrity_integrity(finalOptions, sri);
  return finalOptions.full ? sri : sri.integrity;
};

/* harmony default export */ var src_integrity = (main);
// EXTERNAL MODULE: external "events"
var external_events_ = __webpack_require__(24);

// CONCATENATED MODULE: ./src/PopupHandler.ts








function PopupHandler_createSuper(Derived) { var hasNativeReflectConstruct = PopupHandler_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = getPrototypeOf_default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = getPrototypeOf_default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return possibleConstructorReturn_default()(this, result); }; }

function PopupHandler_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }




var PopupHandler_PopupHandler = /*#__PURE__*/function (_EventEmitter) {
  inherits_default()(PopupHandler, _EventEmitter);

  var _super = PopupHandler_createSuper(PopupHandler);

  function PopupHandler(_ref) {
    var _this;

    var url = _ref.url,
        target = _ref.target,
        features = _ref.features;

    classCallCheck_default()(this, PopupHandler);

    _this = _super.call(this);

    defineProperty_default()(assertThisInitialized_default()(_this), "url", void 0);

    defineProperty_default()(assertThisInitialized_default()(_this), "target", void 0);

    defineProperty_default()(assertThisInitialized_default()(_this), "features", void 0);

    defineProperty_default()(assertThisInitialized_default()(_this), "window", void 0);

    defineProperty_default()(assertThisInitialized_default()(_this), "windowTimer", void 0);

    defineProperty_default()(assertThisInitialized_default()(_this), "iClosedWindow", void 0);

    _this.url = url;
    _this.target = target || "_blank";
    _this.features = features || getPopupFeatures();
    _this.window = undefined;
    _this.windowTimer = undefined;
    _this.iClosedWindow = false;

    _this._setupTimer();

    return _this;
  }

  createClass_default()(PopupHandler, [{
    key: "_setupTimer",
    value: function _setupTimer() {
      var _this2 = this;

      this.windowTimer = Number(setInterval(function () {
        if (_this2.window && _this2.window.closed) {
          clearInterval(_this2.windowTimer);

          if (!_this2.iClosedWindow) {
            _this2.emit("close");
          }

          _this2.iClosedWindow = false;
          _this2.window = undefined;
        }

        if (_this2.window === undefined) clearInterval(_this2.windowTimer);
      }, 500));
    }
  }, {
    key: "open",
    value: function open() {
      var _this$window;

      this.window = window.open(this.url.href, this.target, this.features);
      if ((_this$window = this.window) !== null && _this$window !== void 0 && _this$window.focus) this.window.focus();
      return Promise.resolve();
    }
  }, {
    key: "close",
    value: function close() {
      this.iClosedWindow = true;
      if (this.window) this.window.close();
    }
  }, {
    key: "redirect",
    value: function redirect(locationReplaceOnRedirect) {
      if (locationReplaceOnRedirect) {
        window.location.replace(this.url.href);
      } else {
        window.location.href = this.url.href;
      }
    }
  }]);

  return PopupHandler;
}(external_events_["EventEmitter"]);

/* harmony default export */ var src_PopupHandler = (PopupHandler_PopupHandler);
// CONCATENATED MODULE: ./src/siteMetadata.ts





/**
 * Returns whether the given image URL exists
 * @param url - the url of the image
 * @returns - whether the image exists
 */

function imgExists(url) {
  return new Promise(function (resolve, reject) {
    try {
      var img = document.createElement("img");

      img.onload = function () {
        return resolve(true);
      };

      img.onerror = function () {
        return resolve(false);
      };

      img.src = url;
    } catch (e) {
      reject(e);
    }
  });
}
/**
 * Extracts a name for the site from the DOM
 */


var getSiteName = function getSiteName(window) {
  var document = window.document;
  var siteName = document.querySelector('head > meta[property="og:site_name"]');

  if (siteName) {
    return siteName.content;
  }

  var metaTitle = document.querySelector('head > meta[name="title"]');

  if (metaTitle) {
    return metaTitle.content;
  }

  if (document.title && document.title.length > 0) {
    return document.title;
  }

  return window.location.hostname;
};
/**
 * Extracts an icon for the site from the DOM
 */


function getSiteIcon(_x) {
  return _getSiteIcon.apply(this, arguments);
}
/**
 * Gets site metadata and returns it
 *
 */


function _getSiteIcon() {
  _getSiteIcon = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee2(window) {
    var document, icon;
    return regenerator_default.a.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            document = window.document; // Use the site's favicon if it exists

            icon = document.querySelector('head > link[rel="shortcut icon"]');
            _context2.t0 = icon;

            if (!_context2.t0) {
              _context2.next = 7;
              break;
            }

            _context2.next = 6;
            return imgExists(icon.href);

          case 6:
            _context2.t0 = _context2.sent;

          case 7:
            if (!_context2.t0) {
              _context2.next = 9;
              break;
            }

            return _context2.abrupt("return", icon.href);

          case 9:
            // Search through available icons in no particular order
            icon = Array.from(document.querySelectorAll('head > link[rel="icon"]')).find(function (_icon) {
              return Boolean(_icon.href);
            });
            _context2.t1 = icon;

            if (!_context2.t1) {
              _context2.next = 15;
              break;
            }

            _context2.next = 14;
            return imgExists(icon.href);

          case 14:
            _context2.t1 = _context2.sent;

          case 15:
            if (!_context2.t1) {
              _context2.next = 17;
              break;
            }

            return _context2.abrupt("return", icon.href);

          case 17:
            return _context2.abrupt("return", null);

          case 18:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _getSiteIcon.apply(this, arguments);
}

var getSiteMetadata = /*#__PURE__*/function () {
  var _ref = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee() {
    return regenerator_default.a.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.t0 = getSiteName(window);
            _context.next = 3;
            return getSiteIcon(window);

          case 3:
            _context.t1 = _context.sent;
            return _context.abrupt("return", {
              name: _context.t0,
              icon: _context.t1
            });

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function getSiteMetadata() {
    return _ref.apply(this, arguments);
  };
}();
/**
 * Sends site metadata over an RPC request.
 */


function sendSiteMetadata(_x2) {
  return _sendSiteMetadata.apply(this, arguments);
}

function _sendSiteMetadata() {
  _sendSiteMetadata = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee3(engine) {
    var domainMetadata;
    return regenerator_default.a.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.prev = 0;
            _context3.next = 3;
            return getSiteMetadata();

          case 3:
            domainMetadata = _context3.sent;
            // call engine.handle directly to avoid normal RPC request handling
            engine.handle({
              jsonrpc: "2.0",
              id: getPreopenInstanceId(),
              method: "wallet_sendDomainMetadata",
              params: domainMetadata
            }, NOOP);
            _context3.next = 10;
            break;

          case 7:
            _context3.prev = 7;
            _context3.t0 = _context3["catch"](0);
            loglevel.error({
              message: messages.errors.sendSiteMetadata(),
              originalError: _context3.t0
            });

          case 10:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[0, 7]]);
  }));
  return _sendSiteMetadata.apply(this, arguments);
}
// CONCATENATED MODULE: ./src/embed.ts





var _excluded = ["host", "chainId", "networkName"];

var _defaultVerifiers;

function embed_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function embed_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { embed_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { embed_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
















var defaultVerifiers = (_defaultVerifiers = {}, defineProperty_default()(_defaultVerifiers, LOGIN_PROVIDER.GOOGLE, true), defineProperty_default()(_defaultVerifiers, LOGIN_PROVIDER.FACEBOOK, true), defineProperty_default()(_defaultVerifiers, LOGIN_PROVIDER.REDDIT, true), defineProperty_default()(_defaultVerifiers, LOGIN_PROVIDER.TWITCH, true), defineProperty_default()(_defaultVerifiers, LOGIN_PROVIDER.DISCORD, true), _defaultVerifiers);
var iframeIntegrity = "sha384-n4YBo/i0keGjOFCIdd6akNO3Hsc/Y0McDFxO36AMcSZbfe7AYtFUDQiYA17NB+Gj";
var expectedCacheControlHeader = "max-age=3600";
var UNSAFE_METHODS = ["eth_sendTransaction", "eth_signTypedData", "eth_signTypedData_v3", "eth_signTypedData_v4", "personal_sign", "eth_getEncryptionPublicKey", "eth_decrypt"];
var isLocalStorageAvailable = storageAvailable("localStorage"); // preload for iframe doesn't work https://bugs.chromium.org/p/chromium/issues/detail?id=593267

(function () {
  var _preLoadIframe = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee() {
    var torusIframeHtml, _yield$getTorusUrl, torusUrl;

    return regenerator_default.a.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;

            if (!(typeof document === "undefined")) {
              _context.next = 3;
              break;
            }

            return _context.abrupt("return");

          case 3:
            torusIframeHtml = document.createElement("link");
            _context.next = 6;
            return getTorusUrl("production", {
              check: false,
              hash: iframeIntegrity,
              version: ""
            });

          case 6:
            _yield$getTorusUrl = _context.sent;
            torusUrl = _yield$getTorusUrl.torusUrl;
            torusIframeHtml.href = "".concat(torusUrl, "/popup");
            torusIframeHtml.crossOrigin = "anonymous";
            torusIframeHtml.type = "text/html";
            torusIframeHtml.rel = "prefetch";

            if (torusIframeHtml.relList && torusIframeHtml.relList.supports) {
              if (torusIframeHtml.relList.supports("prefetch")) {
                document.head.appendChild(torusIframeHtml);
              }
            }

            _context.next = 18;
            break;

          case 15:
            _context.prev = 15;
            _context.t0 = _context["catch"](0);
            loglevel.warn(_context.t0);

          case 18:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[0, 15]]);
  }));

  function preLoadIframe() {
    return _preLoadIframe.apply(this, arguments);
  }

  return preLoadIframe;
})()();

var embed_Torus = /*#__PURE__*/function () {
  function Torus() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$buttonPosition = _ref.buttonPosition,
        buttonPosition = _ref$buttonPosition === void 0 ? BUTTON_POSITION.BOTTOM_LEFT : _ref$buttonPosition,
        _ref$modalZIndex = _ref.modalZIndex,
        modalZIndex = _ref$modalZIndex === void 0 ? 99999 : _ref$modalZIndex,
        _ref$apiKey = _ref.apiKey,
        apiKey = _ref$apiKey === void 0 ? "torus-default" : _ref$apiKey;

    classCallCheck_default()(this, Torus);

    defineProperty_default()(this, "buttonPosition", BUTTON_POSITION.BOTTOM_LEFT);

    defineProperty_default()(this, "torusUrl", void 0);

    defineProperty_default()(this, "torusIframe", void 0);

    defineProperty_default()(this, "styleLink", void 0);

    defineProperty_default()(this, "isLoggedIn", void 0);

    defineProperty_default()(this, "isInitialized", void 0);

    defineProperty_default()(this, "torusWidgetVisibility", void 0);

    defineProperty_default()(this, "torusAlert", void 0);

    defineProperty_default()(this, "nodeDetailManager", void 0);

    defineProperty_default()(this, "torusJs", void 0);

    defineProperty_default()(this, "apiKey", void 0);

    defineProperty_default()(this, "modalZIndex", void 0);

    defineProperty_default()(this, "alertZIndex", void 0);

    defineProperty_default()(this, "torusAlertContainer", void 0);

    defineProperty_default()(this, "isIframeFullScreen", void 0);

    defineProperty_default()(this, "whiteLabel", void 0);

    defineProperty_default()(this, "requestedVerifier", void 0);

    defineProperty_default()(this, "currentVerifier", void 0);

    defineProperty_default()(this, "embedTranslations", void 0);

    defineProperty_default()(this, "ethereum", void 0);

    defineProperty_default()(this, "provider", void 0);

    defineProperty_default()(this, "communicationMux", void 0);

    defineProperty_default()(this, "isLoginCallback", void 0);

    defineProperty_default()(this, "dappStorageKey", void 0);

    defineProperty_default()(this, "paymentProviders", config.paymentProviders);

    this.buttonPosition = buttonPosition;
    this.torusUrl = "";
    this.isLoggedIn = false; // ethereum.enable working

    this.isInitialized = false; // init done

    this.torusWidgetVisibility = true;
    this.requestedVerifier = "";
    this.currentVerifier = "";
    this.nodeDetailManager = new fetch_node_details_default.a();
    this.torusJs = new torus_js_default.a({
      metadataHost: "https://metadata.tor.us",
      allowHost: "https://signer.tor.us/api/allow"
    });
    this.apiKey = apiKey;
    torus_js_default.a.setAPIKey(apiKey);
    Object(http_helpers_["setAPIKey"])(apiKey);
    this.modalZIndex = modalZIndex;
    this.alertZIndex = modalZIndex + 1000;
    this.isIframeFullScreen = false;
    this.dappStorageKey = "";
  }

  createClass_default()(Torus, [{
    key: "init",
    value: function () {
      var _init = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee4() {
        var _this = this;

        var _ref2,
            _ref2$buildEnv,
            buildEnv,
            _ref2$enableLogging,
            enableLogging,
            _ref2$enabledVerifier,
            enabledVerifiers,
            _ref2$network,
            network,
            _ref2$loginConfig,
            loginConfig,
            _ref2$showTorusButton,
            showTorusButton,
            _ref2$integrity,
            integrity,
            whiteLabel,
            _ref2$skipTKey,
            skipTKey,
            _ref2$useLocalStorage,
            useLocalStorage,
            _yield$getTorusUrl2,
            torusUrl,
            logLevel,
            dappStorageKey,
            storedKey,
            generatedKey,
            torusIframeUrl,
            link,
            _ref3,
            _ref3$defaultLanguage,
            defaultLanguage,
            _ref3$customTranslati,
            customTranslations,
            mergedTranslations,
            languageTranslations,
            handleSetup,
            fetchUrl,
            resp,
            response,
            calculatedIntegrity,
            _args4 = arguments;

        return regenerator_default.a.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _ref2 = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {}, _ref2$buildEnv = _ref2.buildEnv, buildEnv = _ref2$buildEnv === void 0 ? TORUS_BUILD_ENV.PRODUCTION : _ref2$buildEnv, _ref2$enableLogging = _ref2.enableLogging, enableLogging = _ref2$enableLogging === void 0 ? false : _ref2$enableLogging, _ref2$enabledVerifier = _ref2.enabledVerifiers, enabledVerifiers = _ref2$enabledVerifier === void 0 ? defaultVerifiers : _ref2$enabledVerifier, _ref2$network = _ref2.network, network = _ref2$network === void 0 ? {
                  host: "mainnet",
                  chainId: null,
                  networkName: "",
                  blockExplorer: "",
                  ticker: "",
                  tickerName: ""
                } : _ref2$network, _ref2$loginConfig = _ref2.loginConfig, loginConfig = _ref2$loginConfig === void 0 ? {} : _ref2$loginConfig, _ref2$showTorusButton = _ref2.showTorusButton, showTorusButton = _ref2$showTorusButton === void 0 ? true : _ref2$showTorusButton, _ref2$integrity = _ref2.integrity, integrity = _ref2$integrity === void 0 ? {
                  check: false,
                  hash: iframeIntegrity,
                  version: ""
                } : _ref2$integrity, whiteLabel = _ref2.whiteLabel, _ref2$skipTKey = _ref2.skipTKey, skipTKey = _ref2$skipTKey === void 0 ? false : _ref2$skipTKey, _ref2$useLocalStorage = _ref2.useLocalStorage, useLocalStorage = _ref2$useLocalStorage === void 0 ? false : _ref2$useLocalStorage;

                if (!this.isInitialized) {
                  _context4.next = 3;
                  break;
                }

                throw new Error("Already initialized");

              case 3:
                _context4.next = 5;
                return getTorusUrl(buildEnv, integrity);

              case 5:
                _yield$getTorusUrl2 = _context4.sent;
                torusUrl = _yield$getTorusUrl2.torusUrl;
                logLevel = _yield$getTorusUrl2.logLevel;
                loglevel.info(torusUrl, "url loaded");
                this.torusUrl = torusUrl;
                this.whiteLabel = whiteLabel;
                loglevel.setDefaultLevel(logLevel);
                if (enableLogging) loglevel.enableAll();else loglevel.disableAll();
                this.torusWidgetVisibility = showTorusButton;
                dappStorageKey = "";

                if (isLocalStorageAvailable && useLocalStorage) {
                  storedKey = window.localStorage.getItem(config.localStorageKey);
                  if (storedKey) dappStorageKey = storedKey;else {
                    generatedKey = "torus-app-".concat(getPreopenInstanceId());
                    window.localStorage.setItem(config.localStorageKey, generatedKey);
                    dappStorageKey = generatedKey;
                  }
                }

                this.dappStorageKey = dappStorageKey;
                torusIframeUrl = new URL(torusUrl);
                if (torusIframeUrl.pathname.endsWith("/")) torusIframeUrl.pathname += "popup";else torusIframeUrl.pathname += "/popup";

                if (dappStorageKey) {
                  torusIframeUrl.hash = "#dappStorageKey=".concat(dappStorageKey);
                } // Iframe code


                this.torusIframe = htmlToElement("<iframe\n        id=\"torusIframe\"\n        class=\"torusIframe\"\n        src=\"".concat(torusIframeUrl.href, "\"\n        style=\"display: none; position: fixed; top: 0; right: 0; width: 100%;\n        height: 100%; border: none; border-radius: 0; z-index: ").concat(this.modalZIndex, "\"\n      ></iframe>"));
                this.torusAlertContainer = htmlToElement('<div id="torusAlertContainer"></div>');
                this.torusAlertContainer.style.display = "none";
                this.torusAlertContainer.style.setProperty("z-index", this.alertZIndex.toString());
                link = window.document.createElement("link");
                link.setAttribute("rel", "stylesheet");
                link.setAttribute("type", "text/css");
                link.setAttribute("href", "".concat(torusUrl, "/css/widget.css"));
                this.styleLink = link;
                _ref3 = this.whiteLabel || {}, _ref3$defaultLanguage = _ref3.defaultLanguage, defaultLanguage = _ref3$defaultLanguage === void 0 ? utils_getUserLanguage() : _ref3$defaultLanguage, _ref3$customTranslati = _ref3.customTranslations, customTranslations = _ref3$customTranslati === void 0 ? {} : _ref3$customTranslati;
                mergedTranslations = external_lodash_merge_default()(config.translations, customTranslations);
                languageTranslations = mergedTranslations[defaultLanguage] || config.translations[utils_getUserLanguage()];
                this.embedTranslations = languageTranslations.embed;

                handleSetup = /*#__PURE__*/function () {
                  var _ref4 = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee3() {
                    return regenerator_default.a.wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            _context3.next = 2;
                            return documentReady();

                          case 2:
                            return _context3.abrupt("return", new Promise(function (resolve, reject) {
                              _this.torusIframe.onload = /*#__PURE__*/asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee2() {
                                var initStream;
                                return regenerator_default.a.wrap(function _callee2$(_context2) {
                                  while (1) {
                                    switch (_context2.prev = _context2.next) {
                                      case 0:
                                        // only do this if iframe is not full screen
                                        _this._setupWeb3();

                                        initStream = _this.communicationMux.getStream("init_stream");
                                        initStream.on("data", function (chunk) {
                                          var name = chunk.name,
                                              data = chunk.data,
                                              error = chunk.error;

                                          if (name === "init_complete" && data.success) {
                                            // resolve promise
                                            _this.isInitialized = true;

                                            _this._displayIframe(_this.isIframeFullScreen);

                                            resolve(undefined);
                                          } else if (error) {
                                            reject(new Error(error));
                                          }
                                        });
                                        initStream.write({
                                          name: "init_stream",
                                          data: {
                                            enabledVerifiers: enabledVerifiers,
                                            loginConfig: loginConfig,
                                            whiteLabel: _this.whiteLabel,
                                            buttonPosition: _this.buttonPosition,
                                            torusWidgetVisibility: _this.torusWidgetVisibility,
                                            apiKey: _this.apiKey,
                                            skipTKey: skipTKey,
                                            network: network
                                          }
                                        });

                                      case 4:
                                      case "end":
                                        return _context2.stop();
                                    }
                                  }
                                }, _callee2);
                              }));
                              window.document.head.appendChild(_this.styleLink);
                              window.document.body.appendChild(_this.torusIframe);
                              window.document.body.appendChild(_this.torusAlertContainer);
                            }));

                          case 3:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3);
                  }));

                  return function handleSetup() {
                    return _ref4.apply(this, arguments);
                  };
                }();

                if (!(buildEnv === "production" && integrity.check)) {
                  _context4.next = 55;
                  break;
                }

                // hacky solution to check for iframe integrity
                fetchUrl = "".concat(torusUrl, "/popup");
                _context4.next = 38;
                return fetch(fetchUrl, {
                  cache: "reload"
                });

              case 38:
                resp = _context4.sent;

                if (!(resp.headers.get("Cache-Control") !== expectedCacheControlHeader)) {
                  _context4.next = 41;
                  break;
                }

                throw new Error("Unexpected Cache-Control headers, got ".concat(resp.headers.get("Cache-Control")));

              case 41:
                _context4.next = 43;
                return resp.text();

              case 43:
                response = _context4.sent;
                calculatedIntegrity = src_integrity({
                  algorithms: ["sha384"]
                }, response);
                loglevel.info(calculatedIntegrity, "integrity");

                if (!(calculatedIntegrity === integrity.hash)) {
                  _context4.next = 51;
                  break;
                }

                _context4.next = 49;
                return handleSetup();

              case 49:
                _context4.next = 53;
                break;

              case 51:
                this.clearInit();
                throw new Error("Integrity check failed");

              case 53:
                _context4.next = 57;
                break;

              case 55:
                _context4.next = 57;
                return handleSetup();

              case 57:
                return _context4.abrupt("return", undefined);

              case 58:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function init() {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "login",
    value: function login() {
      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref6$verifier = _ref6.verifier,
          verifier = _ref6$verifier === void 0 ? "" : _ref6$verifier;

      if (!this.isInitialized) throw new Error("Call init() first");
      this.requestedVerifier = verifier;
      return this.ethereum.enable();
    }
  }, {
    key: "logout",
    value: function logout() {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        if (!_this2.isLoggedIn) {
          reject(new Error("User has not logged in yet"));
          return;
        }

        var logOutStream = _this2.communicationMux.getStream("logout");

        logOutStream.write({
          name: "logOut"
        });

        var statusStream = _this2.communicationMux.getStream("status");

        var statusStreamHandler = function statusStreamHandler(status) {
          if (!status.loggedIn) {
            _this2.isLoggedIn = false;
            _this2.currentVerifier = "";
            _this2.requestedVerifier = "";
            resolve();
          } else reject(new Error("Some Error Occured"));
        };

        handleStream(statusStream, "data", statusStreamHandler);
      });
    }
  }, {
    key: "cleanUp",
    value: function () {
      var _cleanUp = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee5() {
        return regenerator_default.a.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!this.isLoggedIn) {
                  _context5.next = 3;
                  break;
                }

                _context5.next = 3;
                return this.logout();

              case 3:
                this.clearInit();

              case 4:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function cleanUp() {
        return _cleanUp.apply(this, arguments);
      }

      return cleanUp;
    }()
  }, {
    key: "clearInit",
    value: function clearInit() {
      function isElement(element) {
        return element instanceof Element || element instanceof HTMLDocument;
      }

      if (isElement(this.styleLink) && window.document.body.contains(this.styleLink)) {
        this.styleLink.remove();
        this.styleLink = undefined;
      }

      if (isElement(this.torusIframe) && window.document.body.contains(this.torusIframe)) {
        this.torusIframe.remove();
        this.torusIframe = undefined;
      }

      if (isElement(this.torusAlertContainer) && window.document.body.contains(this.torusAlertContainer)) {
        this.torusAlert = undefined;
        this.torusAlertContainer.remove();
        this.torusAlertContainer = undefined;
      }

      this.isInitialized = false;
    }
  }, {
    key: "hideTorusButton",
    value: function hideTorusButton() {
      this.torusWidgetVisibility = false;

      this._sendWidgetVisibilityStatus(false);

      this._displayIframe();
    }
  }, {
    key: "showTorusButton",
    value: function showTorusButton() {
      this.torusWidgetVisibility = true;

      this._sendWidgetVisibilityStatus(true);

      this._displayIframe();
    }
  }, {
    key: "setProvider",
    value: function setProvider() {
      var _this3 = this;

      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _ref7$host = _ref7.host,
          host = _ref7$host === void 0 ? "mainnet" : _ref7$host,
          _ref7$chainId = _ref7.chainId,
          chainId = _ref7$chainId === void 0 ? null : _ref7$chainId,
          _ref7$networkName = _ref7.networkName,
          networkName = _ref7$networkName === void 0 ? "" : _ref7$networkName,
          rest = objectWithoutProperties_default()(_ref7, _excluded);

      return new Promise(function (resolve, reject) {
        var providerChangeStream = _this3.communicationMux.getStream("provider_change");

        var handler = function handler(chunk) {
          var _chunk$data = chunk.data,
              err = _chunk$data.err,
              success = _chunk$data.success;
          loglevel.info(chunk);

          if (err) {
            reject(err);
          } else if (success) {
            resolve();
          } else reject(new Error("some error occured"));
        };

        handleStream(providerChangeStream, "data", handler);
        var preopenInstanceId = getPreopenInstanceId();

        _this3._handleWindow(preopenInstanceId, {
          target: "_blank",
          features: FEATURES_PROVIDER_CHANGE_WINDOW
        });

        providerChangeStream.write({
          name: "show_provider_change",
          data: {
            network: embed_objectSpread({
              host: host,
              chainId: chainId,
              networkName: networkName
            }, rest),
            preopenInstanceId: preopenInstanceId,
            override: false
          }
        });
      });
    }
  }, {
    key: "showWallet",
    value: function showWallet(path) {
      var _this4 = this;

      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var showWalletStream = this.communicationMux.getStream("show_wallet");
      var finalPath = path ? "/".concat(path) : "";
      showWalletStream.write({
        name: "show_wallet",
        data: {
          path: finalPath
        }
      });

      var showWalletHandler = function showWalletHandler(chunk) {
        if (chunk.name === "show_wallet_instance") {
          // Let the error propogate up (hence, no try catch)
          var instanceId = chunk.data.instanceId;
          var finalUrl = new URL("".concat(_this4.torusUrl, "/wallet").concat(finalPath)); // Using URL constructor to prevent js injection and allow parameter validation.!

          finalUrl.searchParams.append("integrity", "true");
          finalUrl.searchParams.append("instanceId", instanceId);
          Object.keys(params).forEach(function (x) {
            finalUrl.searchParams.append(x, params[x]);
          });

          if (_this4.dappStorageKey) {
            finalUrl.hash = "#dappStorageKey=".concat(_this4.dappStorageKey);
          }

          var walletWindow = new src_PopupHandler({
            url: finalUrl,
            features: FEATURES_DEFAULT_WALLET_WINDOW
          });
          walletWindow.open();
        }
      };

      handleStream(showWalletStream, "data", showWalletHandler);
    }
  }, {
    key: "getPublicAddress",
    value: function () {
      var _getPublicAddress = asyncToGenerator_default()( /*#__PURE__*/regenerator_default.a.mark(function _callee6(_ref8) {
        var verifier, verifierId, _ref8$isExtended, isExtended, nodeDetails, endpoints, torusNodePubs, walletVerifier, openloginVerifier, existingV1User, v2User, newV2User;

        return regenerator_default.a.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                verifier = _ref8.verifier, verifierId = _ref8.verifierId, _ref8$isExtended = _ref8.isExtended, isExtended = _ref8$isExtended === void 0 ? false : _ref8$isExtended;

                if (!(!config.supportedVerifierList.includes(verifier) || !WALLET_OPENLOGIN_VERIFIER_MAP[verifier])) {
                  _context6.next = 3;
                  break;
                }

                throw new Error("Unsupported verifier");

              case 3:
                _context6.next = 5;
                return this.nodeDetailManager.getNodeDetails(false, true);

              case 5:
                nodeDetails = _context6.sent;
                endpoints = nodeDetails.torusNodeEndpoints;
                torusNodePubs = nodeDetails.torusNodePub;
                walletVerifier = verifier;
                openloginVerifier = WALLET_OPENLOGIN_VERIFIER_MAP[verifier];
                _context6.prev = 10;
                _context6.next = 13;
                return this.torusJs.getUserTypeAndAddress(endpoints, torusNodePubs, {
                  verifier: walletVerifier,
                  verifierId: verifierId
                });

              case 13:
                existingV1User = _context6.sent;

                if (!(existingV1User.typeOfUser === "v1")) {
                  _context6.next = 18;
                  break;
                }

                if (isExtended) {
                  _context6.next = 17;
                  break;
                }

                return _context6.abrupt("return", existingV1User.address);

              case 17:
                return _context6.abrupt("return", existingV1User);

              case 18:
                _context6.next = 20;
                return this.torusJs.getUserTypeAndAddress(endpoints, torusNodePubs, {
                  verifier: openloginVerifier,
                  verifierId: verifierId
                }, true);

              case 20:
                v2User = _context6.sent;

                if (isExtended) {
                  _context6.next = 23;
                  break;
                }

                return _context6.abrupt("return", v2User.address);

              case 23:
                return _context6.abrupt("return", v2User);

              case 26:
                _context6.prev = 26;
                _context6.t0 = _context6["catch"](10);

                if (!(_context6.t0 !== null && _context6.t0 !== void 0 && _context6.t0.message.includes("Verifier + VerifierID has not yet been assigned"))) {
                  _context6.next = 35;
                  break;
                }

                _context6.next = 31;
                return this.torusJs.getUserTypeAndAddress(endpoints, torusNodePubs, {
                  verifier: openloginVerifier,
                  verifierId: verifierId
                }, true);

              case 31:
                newV2User = _context6.sent;

                if (isExtended) {
                  _context6.next = 34;
                  break;
                }

                return _context6.abrupt("return", newV2User.address);

              case 34:
                return _context6.abrupt("return", newV2User);

              case 35:
                throw _context6.t0;

              case 36:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this, [[10, 26]]);
      }));

      function getPublicAddress(_x) {
        return _getPublicAddress.apply(this, arguments);
      }

      return getPublicAddress;
    }()
  }, {
    key: "getUserInfo",
    value: function getUserInfo(message) {
      var _this5 = this;

      return new Promise(function (resolve, reject) {
        if (_this5.isLoggedIn) {
          var userInfoAccessStream = _this5.communicationMux.getStream("user_info_access");

          userInfoAccessStream.write({
            name: "user_info_access_request"
          });

          var userInfoAccessHandler = function userInfoAccessHandler(chunk) {
            var name = chunk.name,
                _chunk$data2 = chunk.data,
                approved = _chunk$data2.approved,
                payload = _chunk$data2.payload,
                rejected = _chunk$data2.rejected,
                newRequest = _chunk$data2.newRequest;

            if (name === "user_info_access_response") {
              if (approved) {
                resolve(payload);
              } else if (rejected) {
                reject(new Error("User rejected the request"));
              } else if (newRequest) {
                var userInfoStream = _this5.communicationMux.getStream("user_info");

                var userInfoHandler = function userInfoHandler(handlerChunk) {
                  if (handlerChunk.name === "user_info_response") {
                    if (handlerChunk.data.approved) {
                      resolve(handlerChunk.data.payload);
                    } else {
                      reject(new Error("User rejected the request"));
                    }
                  }
                };

                handleStream(userInfoStream, "data", userInfoHandler);
                var preopenInstanceId = getPreopenInstanceId();

                _this5._handleWindow(preopenInstanceId, {
                  target: "_blank",
                  features: FEATURES_PROVIDER_CHANGE_WINDOW
                });

                userInfoStream.write({
                  name: "user_info_request",
                  data: {
                    message: message,
                    preopenInstanceId: preopenInstanceId
                  }
                });
              }
            }
          };

          handleStream(userInfoAccessStream, "data", userInfoAccessHandler);
        } else reject(new Error("User has not logged in yet"));
      });
    }
  }, {
    key: "initiateTopup",
    value: function initiateTopup(provider, params) {
      var _this6 = this;

      return new Promise(function (resolve, reject) {
        if (_this6.isInitialized) {
          var _validatePaymentProvi = validatePaymentProvider(provider, params),
              errors = _validatePaymentProvi.errors,
              isValid = _validatePaymentProvi.isValid;

          if (!isValid) {
            reject(new Error(JSON.stringify(errors)));
            return;
          }

          var topupStream = _this6.communicationMux.getStream("topup");

          var topupHandler = function topupHandler(chunk) {
            if (chunk.name === "topup_response") {
              if (chunk.data.success) {
                resolve(chunk.data.success);
              } else {
                reject(new Error(chunk.data.error));
              }
            }
          };

          handleStream(topupStream, "data", topupHandler);
          var preopenInstanceId = getPreopenInstanceId();

          _this6._handleWindow(preopenInstanceId);

          topupStream.write({
            name: "topup_request",
            data: {
              provider: provider,
              params: params,
              preopenInstanceId: preopenInstanceId
            }
          });
        } else reject(new Error("Torus is not initialized yet"));
      });
    }
  }, {
    key: "_handleWindow",
    value: function _handleWindow(preopenInstanceId) {
      var _ref9 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          url = _ref9.url,
          target = _ref9.target,
          features = _ref9.features;

      if (preopenInstanceId) {
        var windowStream = this.communicationMux.getStream("window");
        var finalUrl = new URL(url || "".concat(this.torusUrl, "/redirect?preopenInstanceId=").concat(preopenInstanceId));

        if (this.dappStorageKey) {
          // If multiple instances, it returns the first one
          if (finalUrl.hash) finalUrl.hash += "&dappStorageKey=".concat(this.dappStorageKey);else finalUrl.hash = "#dappStorageKey=".concat(this.dappStorageKey);
        }

        var handledWindow = new src_PopupHandler({
          url: finalUrl,
          target: target,
          features: features
        });
        handledWindow.open();

        if (!handledWindow.window) {
          this._createPopupBlockAlert(preopenInstanceId, finalUrl.href);

          return;
        }

        windowStream.write({
          name: "opened_window",
          data: {
            preopenInstanceId: preopenInstanceId
          }
        });

        var closeHandler = function closeHandler(_ref10) {
          var receivedId = _ref10.preopenInstanceId,
              close = _ref10.close;

          if (receivedId === preopenInstanceId && close) {
            handledWindow.close();
            windowStream.removeListener("data", closeHandler);
          }
        };

        windowStream.on("data", closeHandler);
        handledWindow.once("close", function () {
          windowStream.write({
            data: {
              preopenInstanceId: preopenInstanceId,
              closed: true
            }
          });
          windowStream.removeListener("data", closeHandler);
        });
      }
    }
  }, {
    key: "_setEmbedWhiteLabel",
    value: function _setEmbedWhiteLabel(element) {
      // Set whitelabel
      var _ref11 = this.whiteLabel || {},
          theme = _ref11.theme;

      if (theme) {
        var _theme$isDark = theme.isDark,
            isDark = _theme$isDark === void 0 ? false : _theme$isDark,
            _theme$colors = theme.colors,
            colors = _theme$colors === void 0 ? {} : _theme$colors;
        if (isDark) element.classList.add("torus-dark");
        if (colors.torusBrand1) element.style.setProperty("--torus-brand-1", colors.torusBrand1);
        if (colors.torusGray2) element.style.setProperty("--torus-gray-2", colors.torusGray2);
      }
    }
  }, {
    key: "_getLogoUrl",
    value: function _getLogoUrl() {
      var _this$whiteLabel, _this$whiteLabel$them;

      var logoUrl = "".concat(this.torusUrl, "/images/torus_icon-blue.svg");

      if ((_this$whiteLabel = this.whiteLabel) !== null && _this$whiteLabel !== void 0 && (_this$whiteLabel$them = _this$whiteLabel.theme) !== null && _this$whiteLabel$them !== void 0 && _this$whiteLabel$them.isDark) {
        var _this$whiteLabel2;

        logoUrl = ((_this$whiteLabel2 = this.whiteLabel) === null || _this$whiteLabel2 === void 0 ? void 0 : _this$whiteLabel2.logoLight) || logoUrl;
      } else {
        var _this$whiteLabel3;

        logoUrl = ((_this$whiteLabel3 = this.whiteLabel) === null || _this$whiteLabel3 === void 0 ? void 0 : _this$whiteLabel3.logoDark) || logoUrl;
      }

      return logoUrl;
    }
  }, {
    key: "_sendWidgetVisibilityStatus",
    value: function _sendWidgetVisibilityStatus(status) {
      var torusWidgetVisibilityStream = this.communicationMux.getStream("torus-widget-visibility");
      torusWidgetVisibilityStream.write({
        data: status
      });
    }
  }, {
    key: "_displayIframe",
    value: function _displayIframe() {
      var isFull = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var style = {}; // set phase

      if (!isFull) {
        style.display = this.torusWidgetVisibility ? "block" : "none";
        style.height = "70px";
        style.width = "70px";

        switch (this.buttonPosition) {
          case BUTTON_POSITION.TOP_LEFT:
            style.top = "0px";
            style.left = "0px";
            style.right = "auto";
            style.bottom = "auto";
            break;

          case BUTTON_POSITION.TOP_RIGHT:
            style.top = "0px";
            style.right = "0px";
            style.left = "auto";
            style.bottom = "auto";
            break;

          case BUTTON_POSITION.BOTTOM_RIGHT:
            style.bottom = "0px";
            style.right = "0px";
            style.top = "auto";
            style.left = "auto";
            break;

          case BUTTON_POSITION.BOTTOM_LEFT:
          default:
            style.bottom = "0px";
            style.left = "0px";
            style.top = "auto";
            style.right = "auto";
            break;
        }
      } else {
        style.display = "block";
        style.width = "100%";
        style.height = "100%";
        style.top = "0px";
        style.right = "0px";
        style.left = "0px";
        style.bottom = "0px";
      }

      Object.assign(this.torusIframe.style, style);
      this.isIframeFullScreen = isFull;
    }
  }, {
    key: "_setupWeb3",
    value: function _setupWeb3() {
      var _this7 = this;

      loglevel.info("setupWeb3 running"); // setup background connection

      var metamaskStream = new openlogin_jrpc_["BasePostMessageStream"]({
        name: "embed_metamask",
        target: "iframe_metamask",
        targetWindow: this.torusIframe.contentWindow,
        targetOrigin: new URL(this.torusUrl).origin
      }); // Due to compatibility reasons, we should not set up multiplexing on window.metamaskstream
      // because the MetamaskInpageProvider also attempts to do so.
      // We create another LocalMessageDuplexStream for communication between dapp <> iframe

      var communicationStream = new openlogin_jrpc_["BasePostMessageStream"]({
        name: "embed_comm",
        target: "iframe_comm",
        targetWindow: this.torusIframe.contentWindow,
        targetOrigin: new URL(this.torusUrl).origin
      }); // Backward compatibility with Gotchi :)
      // window.metamaskStream = this.communicationStream
      // compose the inpage provider

      var inpageProvider = new inpage_provider(metamaskStream); // detect eth_requestAccounts and pipe to enable for now

      var detectAccountRequestPrototypeModifier = function detectAccountRequestPrototypeModifier(m) {
        var originalMethod = inpageProvider[m];

        inpageProvider[m] = function providerFunc(method) {
          if (method && method === "eth_requestAccounts") {
            return inpageProvider.enable();
          }

          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          return originalMethod.apply(this, [method].concat(args));
        };
      };

      detectAccountRequestPrototypeModifier("send");
      detectAccountRequestPrototypeModifier("sendAsync");

      inpageProvider.enable = function () {
        return new Promise(function (resolve, reject) {
          // If user is already logged in, we assume they have given access to the website
          inpageProvider.sendAsync({
            jsonrpc: "2.0",
            id: getPreopenInstanceId(),
            method: "eth_requestAccounts",
            params: []
          }, function (err, response) {
            var _ref12 = response || {},
                res = _ref12.result;

            if (err) {
              setTimeout(function () {
                reject(err);
              }, 50);
            } else if (Array.isArray(res) && res.length > 0) {
              // If user is already rehydrated, resolve this
              // else wait for something to be written to status stream
              var handleLoginCb = function handleLoginCb() {
                if (_this7.requestedVerifier !== "" && _this7.currentVerifier !== _this7.requestedVerifier) {
                  var requestedVerifier = _this7.requestedVerifier; // eslint-disable-next-line promise/no-promise-in-callback

                  _this7.logout() // eslint-disable-next-line promise/always-return
                  .then(function (_) {
                    _this7.requestedVerifier = requestedVerifier;

                    _this7._showLoginPopup(true, resolve, reject);
                  }).catch(function (error) {
                    return reject(error);
                  });
                } else {
                  resolve(res);
                }
              };

              if (_this7.isLoggedIn) {
                handleLoginCb();
              } else {
                _this7.isLoginCallback = handleLoginCb;
              }
            } else {
              // set up listener for login
              _this7._showLoginPopup(true, resolve, reject);
            }
          });
        });
      };

      inpageProvider.tryPreopenHandle = function (payload, cb) {
        var _payload = payload;

        if (!Array.isArray(_payload) && UNSAFE_METHODS.includes(_payload.method)) {
          var preopenInstanceId = getPreopenInstanceId();

          _this7._handleWindow(preopenInstanceId, {
            target: "_blank",
            features: FEATURES_CONFIRM_WINDOW
          });

          _payload.preopenInstanceId = preopenInstanceId;
        }

        inpageProvider._rpcEngine.handle(_payload, cb);
      }; // Work around for web3@1.0 deleting the bound `sendAsync` but not the unbound
      // `sendAsync` method on the prototype, causing `this` reference issues with drizzle


      var proxiedInpageProvider = new Proxy(inpageProvider, {
        // straight up lie that we deleted the property so that it doesnt
        // throw an error in strict mode
        deleteProperty: function deleteProperty() {
          return true;
        }
      });
      this.ethereum = proxiedInpageProvider;
      var communicationMux = Object(openlogin_jrpc_["setupMultiplex"])(communicationStream);
      this.communicationMux = communicationMux;
      var windowStream = communicationMux.getStream("window");
      windowStream.on("data", function (chunk) {
        if (chunk.name === "create_window") {
          // url is the url we need to open
          // we can pass the final url upfront so that it removes the step of redirecting to /redirect and waiting for finalUrl
          _this7._createPopupBlockAlert(chunk.data.preopenInstanceId, chunk.data.url);
        }
      }); // show torus widget if button clicked

      var widgetStream = communicationMux.getStream("widget");
      widgetStream.on("data", function (chunk) {
        var data = chunk.data;

        _this7._displayIframe(data);
      }); // Show torus button if wallet has been hydrated/detected

      var statusStream = communicationMux.getStream("status");
      statusStream.on("data", function (status) {
        // login
        if (status.loggedIn) {
          _this7.isLoggedIn = status.loggedIn;
          _this7.currentVerifier = status.verifier;
        } // logout
        else _this7._displayIframe();

        if (_this7.isLoginCallback) {
          _this7.isLoginCallback();

          delete _this7.isLoginCallback;
        }
      });
      this.provider = proxiedInpageProvider;
      if (this.provider.shouldSendMetadata) sendSiteMetadata(this.provider._rpcEngine);

      inpageProvider._initializeState();

      loglevel.debug("Torus - injected provider");
    }
  }, {
    key: "_showLoginPopup",
    value: function _showLoginPopup(calledFromEmbed, resolve, reject) {
      var _this8 = this;

      var loginHandler = function loginHandler(data) {
        var err = data.err,
            selectedAddress = data.selectedAddress;

        if (err) {
          loglevel.error(err);
          if (reject) reject(err);
        } // returns an array (cause accounts expects it)
        else if (resolve) resolve([selectedAddress]);

        if (_this8.isIframeFullScreen) _this8._displayIframe();
      };

      var oauthStream = this.communicationMux.getStream("oauth");

      if (!this.requestedVerifier) {
        this._displayIframe(true);

        handleStream(oauthStream, "data", loginHandler);
        oauthStream.write({
          name: "oauth_modal",
          data: {
            calledFromEmbed: calledFromEmbed
          }
        });
      } else {
        handleStream(oauthStream, "data", loginHandler);
        var preopenInstanceId = getPreopenInstanceId();

        this._handleWindow(preopenInstanceId);

        oauthStream.write({
          name: "oauth",
          data: {
            calledFromEmbed: calledFromEmbed,
            verifier: this.requestedVerifier,
            preopenInstanceId: preopenInstanceId
          }
        });
      }
    }
  }, {
    key: "_createPopupBlockAlert",
    value: function _createPopupBlockAlert(preopenInstanceId, url) {
      var _this9 = this;

      var logoUrl = this._getLogoUrl();

      var torusAlert = htmlToElement('<div id="torusAlert" class="torus-alert--v2">' + "<div id=\"torusAlert__logo\"><img src=\"".concat(logoUrl, "\" /></div>") + "<div>" + "<h1 id=\"torusAlert__title\">".concat(this.embedTranslations.actionRequired, "</h1>") + "<p id=\"torusAlert__desc\">".concat(this.embedTranslations.pendingAction, "</p>") + "</div>" + "</div>");
      var successAlert = htmlToElement("<div><a id=\"torusAlert__btn\">".concat(this.embedTranslations.continue, "</a></div>"));
      var btnContainer = htmlToElement('<div id="torusAlert__btn-container"></div>');
      btnContainer.appendChild(successAlert);
      torusAlert.appendChild(btnContainer);

      var bindOnLoad = function bindOnLoad() {
        successAlert.addEventListener("click", function () {
          _this9._handleWindow(preopenInstanceId, {
            url: url,
            target: "_blank",
            features: FEATURES_CONFIRM_WINDOW
          });

          torusAlert.remove();
          if (_this9.torusAlertContainer.children.length === 0) _this9.torusAlertContainer.style.display = "none";
        });
      };

      this._setEmbedWhiteLabel(torusAlert);

      var attachOnLoad = function attachOnLoad() {
        _this9.torusAlertContainer.style.display = "block";

        _this9.torusAlertContainer.appendChild(torusAlert);
      };

      runOnLoad(attachOnLoad);
      runOnLoad(bindOnLoad);
    }
  }]);

  return Torus;
}();

/* harmony default export */ var src_embed = (embed_Torus);
// CONCATENATED MODULE: ./src/index.ts




/***/ })
/******/ ])["default"];
//# sourceMappingURL=torus.cjs.js.map